*lsp.txt*   LSP


                            NVIM REFERENCE MANUAL


LSP client/framework                                     *lsp* *LSP*

Nvim supports the Language Server Protocol (LSP), which means it acts as
a client to LSP servers and includes a Lua framework `vim.lsp` for building
enhanced LSP tools.

  https://microsoft.github.io/language-server-protocol/

LSP facilitates features like go-to-definition, find-references, hover,
completion, rename, format, refactor, etc., using semantic whole-project
analysis (unlike |ctags|).

                                      Type |gO| to see the table of contents.

==============================================================================
QUICKSTART                                              *lsp-quickstart*

Nvim provides an LSP client, but the servers are provided by third parties.
Follow these steps to get LSP features:

  1. Install the nvim-lspconfig plugin.  It provides common configuration for
     various servers so you can get started quickly.
     https://github.com/neovim/nvim-lspconfig
  2. Install a language server. A list of language servers can be found here:
     https://microsoft.github.io/language-server-protocol/implementors/servers/
     See individual server documentation for installation instructions.
  3. Add `lua require('lspconfig').xx.setup{…}` to your init.vim, where "xx" is
     the name of the relevant config. See the nvim-lspconfig README for details.
     NOTE: Make sure to restart nvim after installing and configuring.
  4. Check that an LSP client has attached to the current buffer:  >

      :lua print(vim.inspect(vim.lsp.buf_get_clients()))
<
                                                        *lsp-config*
Inline diagnostics are enabled automatically, e.g. syntax errors will be
annotated in the buffer.  But you probably also want to use other features
like go-to-definition, hover, etc.

While Nvim does not provide an "auto-completion" framework by default, it is
still possible to get completions from the LSP server. To incorporate these
completions, it is recommended to use |vim.lsp.omnifunc|, which is an 'omnifunc'
handler. When 'omnifunc' is set to `v:lua.vim.lsp.omnifunc`, |i_CTRL-X_CTRL-O|
will provide completions from the language server.

Example config (in init.vim): >

  lua << EOF
    local custom_lsp_attach = function(client)
      -- See `:help nvim_buf_set_keymap()` for more information
      vim.api.nvim_buf_set_keymap(0, 'n', 'K', '<cmd>lua vim.lsp.buf.hover()<CR>', {noremap = true})
      vim.api.nvim_buf_set_keymap(0, 'n', '<c-]>', '<cmd>lua vim.lsp.buf.definition()<CR>', {noremap = true})
      -- ... and other keymappings for LSP

      -- Use LSP as the handler for omnifunc.
      --    See `:help omnifunc` and `:help ins-completion` for more information.
      vim.api.nvim_buf_set_option(0, 'omnifunc', 'v:lua.vim.lsp.omnifunc')

      -- For plugins with an `on_attach` callback, call them here. For example:
      -- require('completion').on_attach()
    end

    -- An example of configuring for `sumneko_lua`,
    --  a language server for Lua.

    -- set the path to the sumneko installation
    local system_name = "Linux" -- (Linux, macOS, or Windows)
    local sumneko_root_path = '/path/to/lua-language-server'
    local sumneko_binary = sumneko_root_path.."/bin/"..system_name.."/lua-language-server"

    require('lspconfig').sumneko_lua.setup({
      cmd = {sumneko_binary, "-E", sumneko_root_path .. "/main.lua"};
      -- An example of settings for an LSP server.
      --    For more options, see nvim-lspconfig
      settings = {
        Lua = {
          runtime = {
            -- Tell the language server which version of Lua you're using (most likely LuaJIT in the case of Neovim)
            version = 'LuaJIT',
            -- Setup your lua path
            path = vim.split(package.path, ';'),
          },
          diagnostics = {
            -- Get the language server to recognize the `vim` global
            globals = {'vim'},
          },
          workspace = {
            -- Make the server aware of Neovim runtime files
            library = {
              [vim.fn.expand('$VIMRUNTIME/lua')] = true,
              [vim.fn.expand('$VIMRUNTIME/lua/vim/lsp')] = true,
            },
          },
        }
      },

      on_attach = custom_lsp_attach
    })
  EOF
<

Full list of features provided by default can be found in |lsp-buf|.

================================================================================
FAQ                                                     *lsp-faq*

- Q: How to force-reload LSP?
  A: Stop all clients, then reload the buffer. >

     :lua vim.lsp.stop_client(vim.lsp.get_active_clients())
     :edit

- Q: Why isn't completion working?
  A: In the buffer where you want to use LSP, check that 'omnifunc' is set to
     "v:lua.vim.lsp.omnifunc": >

     :verbose set omnifunc?

<     Some other plugin may be overriding the option. To avoid that, you could
     set the option in an |after-directory| ftplugin, e.g.
     "after/ftplugin/python.vim".

- Q: How do I run a request synchronously (e.g. for formatting on file save)?
  A: Use the `_sync` variant of the function provided by |lsp-buf|, if it
     exists.

     E.g. code formatting: >

     " Auto-format *.rs (rust) files prior to saving them
     autocmd BufWritePre *.rs lua vim.lsp.buf.formatting_sync(nil, 1000)

<
                                                           *vim.lsp.callbacks*
- Q: What happened to `vim.lsp.callbacks`?
  A: After better defining the interface of |lsp-handler|s, we thought it best
     to remove the generic usage of `callbacks` and transform to `handlers`.
     Due to this, `vim.lsp.callbacks` was renamed to |vim.lsp.handlers|.

                                                           *lsp-vs-treesitter*
- Q: How do LSP and Treesitter compare?
  A: LSP requires a client and language server. The language server uses
     semantic analysis to understand code at a project level. This provides
     language servers with the ability to rename across files, find
     definitions in external libraries and more.

     Treesitter is a language parsing library that provides excellent tools
     for incrementally parsing text and handling errors. This makes it a great
     fit for editors to understand the contents of the current file for things
     like syntax highlighting, simple goto-definitions, scope analysis and
     more.

     LSP and Treesitter are both great tools for editing and inspecting code.

================================================================================
LSP API                                                 *lsp-api*

LSP core API is described at |lsp-core|.  Those are the core functions for
creating and managing clients.

The `vim.lsp.buf_…` functions perform operations for all LSP clients attached
to the given buffer. |lsp-buf|

LSP request/response handlers are implemented as Lua functions (see
|lsp-handler|). The |vim.lsp.handlers| table defines default handlers used
when creating a new client. Keys are LSP method names: >

  :lua print(vim.inspect(vim.tbl_keys(vim.lsp.handlers)))
<
                                                                  *lsp-method*

Methods are the names of requests and notifications as defined by the LSP
specification. These LSP requests/notifications are defined by default:

    callHierarchy/incomingCalls
    callHierarchy/outgoingCalls
    textDocument/codeAction
    textDocument/completion
    textDocument/declaration*
    textDocument/definition
    textDocument/documentHighlight
    textDocument/documentSymbol
    textDocument/formatting
    textDocument/hover
    textDocument/implementation*
    textDocument/publishDiagnostics
    textDocument/rangeFormatting
    textDocument/references
    textDocument/rename
    textDocument/signatureHelp
    textDocument/typeDefinition*
    window/logMessage
    window/showMessage
    window/showMessageRequest
    workspace/applyEdit
    workspace/symbol

* NOTE: These are sometimes not implemented by servers.

                                                                 *lsp-handler*

lsp-handlers are functions with special signatures that are designed to handle
responses and notifications from LSP servers.

For |lsp-request|, each |lsp-handler| has this signature: >

  function(err, method, result, client_id, bufnr, config)
<
        Parameters: ~
            {err}       (table|nil)
                            When the language server is unable to complete a
                            request, a table with information about the error
                            is sent. Otherwise, it is `nil`. See |lsp-response|.
            {method}    (string)
                            The |lsp-method| name.
            {result}    (Result | Params | nil)
                            When the language server is able to succesfully
                            complete a request, this contains the `result` key
                            of the response. See |lsp-response|.
            {client_id} (number)
                            The ID of the |vim.lsp.client|.
            {bufnr}     (Buffer)
                            Buffer handle, or 0 for current.
            {config}    (table)
                            Configuration for the handler.

                            Each handler can define it's own configuration
                            table that allows users to customize the behavior
                            of a particular handler.

                            To configure a particular |lsp-handler|, see:
                                |lsp-handler-configuration|

        Returns: ~
            The |lsp-handler| can respond by returning two values: `result, err`
              Where `err` must be shaped like an RPC error:
                `{ code, message, data? }`

            You can use |vim.lsp.rpc_response_error()| to create this object.

For |lsp-notification|, each |lsp-handler| has this signature: >

  function(err, method, params, client_id, bufnr, config)
<
        Parameters: ~
            {err}       (nil)
                            This is always `nil`.
                            See |lsp-notification|
            {method}    (string)
                            The |lsp-method| name.
            {params}    (Params)
                            This contains the `params` key of the notification.
                            See |lsp-notification|
            {client_id} (number)
                            The ID of the |vim.lsp.client|
            {bufnr}     (nil)
                            `nil`, as the server doesn't have an associated buffer.
            {config}    (table)
                            Configuration for the handler.

                            Each handler can define it's own configuration
                            table that allows users to customize the behavior
                            of a particular handler.

                            For an example, see:
                                |vim.lsp.diagnostic.on_publish_diagnostics()|

                            To configure a particular |lsp-handler|, see:
                                |lsp-handler-configuration|

        Returns: ~
            The |lsp-handler|'s return value will be ignored.

                                                   *lsp-handler-configuration*

To configure the behavior of a builtin |lsp-handler|, the convenient method
|vim.lsp.with()| is provided for users.

  To configure the behavior of |vim.lsp.diagnostic.on_publish_diagnostics()|,
  consider the following example, where a new |lsp-handler| is created using
  |vim.lsp.with()| that no longer generates signs for the diagnostics: >

  vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
    vim.lsp.diagnostic.on_publish_diagnostics, {
      -- Disable signs
      signs = false,
    }
  )
<
  To enable signs, use |vim.lsp.with()| again to create and assign a new
  |lsp-handler| to |vim.lsp.handlers| for the associated method: >

   vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
     vim.lsp.diagnostic.on_publish_diagnostics, {
       -- Enable signs
       signs = true,
     }
   )
<
  To configure a handler on a per-server basis, you can use the {handlers} key
  for |vim.lsp.start_client()| >

   vim.lsp.start_client {
     ..., -- Other configuration omitted.
     handlers = {
       ["textDocument/publishDiagnostics"] = vim.lsp.with(
         vim.lsp.diagnostic.on_publish_diagnostics, {
           -- Disable virtual_text
           virtual_text = false,
         }
       },
     }
<
  or if using 'nvim-lspconfig', you can use the {handlers} key of `setup()`: >

   require('lspconfig').rust_analyzer.setup {
     handlers = {
       ["textDocument/publishDiagnostics"] = vim.lsp.with(
         vim.lsp.diagnostic.on_publish_diagnostics, {
           -- Disable virtual_text
           virtual_text = false
         }
       ),
     }
   }
<
                                                      *lsp-handler-resolution*
Handlers can be set by:

- Setting a field in |vim.lsp.handlers|.                      *vim.lsp.handlers*
    |vim.lsp.handlers| is a global table that contains the default mapping of
    |lsp-method| names to |lsp-handlers|.

    To override the handler for the `"textDocument/definition"` method: >

  vim.lsp.handlers["textDocument/definition"] = my_custom_default_definition
<
- The {handlers} parameter for |vim.lsp.start_client|.
    This will set the |lsp-handler| as the default handler for this server.

    For example: >

  vim.lsp.start_client {
    ..., -- Other configuration ommitted.
    handlers = {
        ["textDocument/definition"] = my_custom_server_definition
    },
  }

- The {handler} parameter for |vim.lsp.buf_request()|.
    This will set the |lsp-handler| ONLY for the current request.

    For example: >

  vim.lsp.buf_request(
    0,
    "textDocument/definition",
    definition_params,
    my_request_custom_definition
  )
<
In summary, the |lsp-handler| will be chosen based on the current |lsp-method|
in the following order:

1. Handler passed to |vim.lsp.buf_request()|, if any.
2. Handler defined in |vim.lsp.start_client()|, if any.
3. Handler defined in |vim.lsp.handlers|, if any.


VIM.LSP.PROTOCOL                                              *vim.lsp.protocol*

Module `vim.lsp.protocol` defines constants dictated by the LSP specification,
and helper functions for creating protocol-related objects.
https://github.com/microsoft/language-server-protocol/raw/gh-pages/_specifications/specification-3-14.md

For example `vim.lsp.protocol.ErrorCodes` allows reverse lookup by number or
name: >

  vim.lsp.protocol.TextDocumentSyncKind.Full == 1
  vim.lsp.protocol.TextDocumentSyncKind[1] == "Full"
<

                                                                *lsp-response*
For the format of the response message, see:
    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#responseMessage

                                                                *lsp-notification*
For the format of the notification message, see:
    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#notificationMessage

================================================================================
LSP HIGHLIGHT                                                    *lsp-highlight*

Reference Highlights:

Highlight groups that are meant to be used by |vim.lsp.buf.document_highlight()|.

You can see more about the differences in types here:
https://microsoft.github.io/language-server-protocol/specification#textDocument_documentHighlight

                                                           *hl-LspReferenceText*
LspReferenceText          used for highlighting "text" references
                                                           *hl-LspReferenceRead*
LspReferenceRead          used for highlighting "read" references
                                                          *hl-LspReferenceWrite*
LspReferenceWrite         used for highlighting "write" references


                                                   *lsp-highlight-diagnostics*
All highlights defined for diagnostics begin with `LspDiagnostics` followed by
the type of highlight (e.g., `Sign`, `Underline`, etc.) and then the Severity
of the highlight (e.g. `Error`, `Warning`, etc.)

Sign, underline and virtual text highlights (by default) are linked to their
corresponding LspDiagnosticsDefault highlight.

For example, the default highlighting for |hl-LspDiagnosticsSignError| is
linked to |hl-LspDiagnosticsDefaultError|. To change the default (and
therefore the linked highlights), use the |:highlight| command: >

    highlight LspDiagnosticsDefaultError guifg="BrightRed"
<

                                               *hl-LspDiagnosticsDefaultError*
LspDiagnosticsDefaultError
  Used as the base highlight group.
  Other LspDiagnostic highlights link to this by default (except Underline)

                                             *hl-LspDiagnosticsDefaultWarning*
LspDiagnosticsDefaultWarning
  Used as the base highlight group.
  Other LspDiagnostic highlights link to this by default (except Underline)

                                         *hl-LspDiagnosticsDefaultInformation*
LspDiagnosticsDefaultInformation
  Used as the base highlight group.
  Other LspDiagnostic highlights link to this by default (except Underline)

                                                *hl-LspDiagnosticsDefaultHint*
LspDiagnosticsDefaultHint
  Used as the base highlight group.
  Other LspDiagnostic highlights link to this by default (except Underline)

                                           *hl-LspDiagnosticsVirtualTextError*
LspDiagnosticsVirtualTextError
  Used for "Error" diagnostic virtual text.
  See |vim.lsp.diagnostic.set_virtual_text()|

                                         *hl-LspDiagnosticsVirtualTextWarning*
LspDiagnosticsVirtualTextWarning
  Used for "Warning" diagnostic virtual text.
  See |vim.lsp.diagnostic.set_virtual_text()|

                                     *hl-LspDiagnosticsVirtualTextInformation*
LspDiagnosticsVirtualTextInformation
  Used for "Information" diagnostic virtual text.
  See |vim.lsp.diagnostic.set_virtual_text()|

                                            *hl-LspDiagnosticsVirtualTextHint*
LspDiagnosticsVirtualTextHint
  Used for "Hint" diagnostic virtual text.
  See |vim.lsp.diagnostic.set_virtual_text()|

                                             *hl-LspDiagnosticsUnderlineError*
LspDiagnosticsUnderlineError
  Used to underline "Error" diagnostics.
  See |vim.lsp.diagnostic.set_underline()|

                                           *hl-LspDiagnosticsUnderlineWarning*
LspDiagnosticsUnderlineWarning
  Used to underline "Warning" diagnostics.
  See |vim.lsp.diagnostic.set_underline()|

                                       *hl-LspDiagnosticsUnderlineInformation*
LspDiagnosticsUnderlineInformation
  Used to underline "Information" diagnostics.
  See |vim.lsp.diagnostic.set_underline()|

                                              *hl-LspDiagnosticsUnderlineHint*
LspDiagnosticsUnderlineHint
  Used to underline "Hint" diagnostics.
  See |vim.lsp.diagnostic.set_underline()|

                                              *hl-LspDiagnosticsFloatingError*
LspDiagnosticsFloatingError
  Used to color "Error" diagnostic messages in diagnostics float.
  See |vim.lsp.diagnostic.show_line_diagnostics()|

                                            *hl-LspDiagnosticsFloatingWarning*
LspDiagnosticsFloatingWarning
  Used to color "Warning" diagnostic messages in diagnostics float.
  See |vim.lsp.diagnostic.show_line_diagnostics()|

                                        *hl-LspDiagnosticsFloatingInformation*
LspDiagnosticsFloatingInformation
  Used to color "Information" diagnostic messages in diagnostics float.
  See |vim.lsp.diagnostic.show_line_diagnostics()|

                                               *hl-LspDiagnosticsFloatingHint*
LspDiagnosticsFloatingHint
  Used to color "Hint" diagnostic messages in diagnostics float.
  See |vim.lsp.diagnostic.show_line_diagnostics()|

                                                  *hl-LspDiagnosticsSignError*
LspDiagnosticsSignError
  Used for "Error" signs in sign column.
  See |vim.lsp.diagnostic.set_signs()|

                                                *hl-LspDiagnosticsSignWarning*
LspDiagnosticsSignWarning
  Used for "Warning" signs in sign column.
  See |vim.lsp.diagnostic.set_signs()|

                                            *hl-LspDiagnosticsSignInformation*
LspDiagnosticsSignInformation
  Used for "Information" signs in sign column.
  See |vim.lsp.diagnostic.set_signs()|

                                                   *hl-LspDiagnosticsSignHint*
LspDiagnosticsSignHint
  Used for "Hint" signs in sign column.
  See |vim.lsp.diagnostic.set_signs()|

==============================================================================
AUTOCOMMANDS                                                *lsp-autocommands*

                                                       *LspDiagnosticsChanged*
LspDiagnosticsChanged           After receiving publishDiagnostics server response


==============================================================================
Lua module: vim.lsp                                                 *lsp-core*

buf_attach_client({bufnr}, {client_id})          *vim.lsp.buf_attach_client()*
                Implements the `textDocument/did…` notifications required to
                track a buffer for any language server.

                Without calling this, the server won't be notified of changes
                to a buffer.

                Parameters: ~
                    {bufnr}      (number) Buffer handle, or 0 for current
                    {client_id}  (number) Client id

buf_get_clients({bufnr})                           *vim.lsp.buf_get_clients()*
                Gets a map of client_id:client pairs for the given buffer,
                where each value is a |vim.lsp.client| object.

                Parameters: ~
                    {bufnr}  (optional, number): Buffer handle, or 0 for
                             current

buf_is_attached({bufnr}, {client_id})              *vim.lsp.buf_is_attached()*
                Checks if a buffer is attached for a particular client.

                Parameters: ~
                    {bufnr}      (number) Buffer handle, or 0 for current
                    {client_id}  (number) the client id

buf_notify({bufnr}, {method}, {params})                 *vim.lsp.buf_notify()*
                Send a notification to a server

                Parameters: ~
                    {bufnr}   [number] (optional): The number of the buffer
                    {method}  [string]: Name of the request method
                    {params}  [string]: Arguments to send to the server

                Return: ~
                    true if any client returns true; false otherwise

                                                       *vim.lsp.buf_request()*
buf_request({bufnr}, {method}, {params}, {handler})
                Sends an async request for all active clients attached to the
                buffer.

                Parameters: ~
                    {bufnr}    (number) Buffer handle, or 0 for current.
                    {method}   (string) LSP method name
                    {params}   (optional, table) Parameters to send to the
                               server
                    {handler}  (optional, function) See |lsp-handler|

                Return: ~
                    2-tuple:
                    • Map of client-id:request-id pairs for all successful
                      requests.
                    • Function which can be used to cancel all the requests.
                      You could instead iterate all clients and call their
                      `cancel_request()` methods.

                                                  *vim.lsp.buf_request_sync()*
buf_request_sync({bufnr}, {method}, {params}, {timeout_ms})
                Sends a request to a server and waits for the response.

                Calls |vim.lsp.buf_request()| but blocks Nvim while awaiting
                the result. Parameters are the same as |vim.lsp.buf_request()|
                but the return result is different. Wait maximum of
                {timeout_ms} (default 100) ms.

                Parameters: ~
                    {bufnr}       (number) Buffer handle, or 0 for current.
                    {method}      (string) LSP method name
                    {params}      (optional, table) Parameters to send to the
                                  server
                    {timeout_ms}  (optional, number, default=100) Maximum time
                                  in milliseconds to wait for a result.

                Return: ~
                    Map of client_id:request_result. On timeout, cancel or
                    error, returns `(nil, err)` where `err` is a string
                    describing the failure reason.

client()                                                      *vim.lsp.client*
                LSP client object. You can get an active client object via
                |vim.lsp.get_client_by_id()| or
                |vim.lsp.get_active_clients()|.

                • Methods:
                  • request(method, params, [handler], bufnr) Sends a request
                    to the server. This is a thin wrapper around
                    {client.rpc.request} with some additional checking. If
                    {handler} is not specified, If one is not found there,
                    then an error will occur. Returns: {status},
                    {[client_id]}. {status} is a boolean indicating if the
                    notification was successful. If it is `false` , then it
                    will always be `false` (the client has shutdown). If
                    {status} is `true` , the function returns {request_id} as
                    the second result. You can use this with
                    `client.cancel_request(request_id)` to cancel the request.
                  • notify(method, params) Sends a notification to an LSP
                    server. Returns: a boolean to indicate if the notification
                    was successful. If it is false, then it will always be
                    false (the client has shutdown).
                  • cancel_request(id) Cancels a request with a given request
                    id. Returns: same as `notify()` .
                  • stop([force]) Stops a client, optionally with force. By
                    default, it will just ask the server to shutdown without
                    force. If you request to stop a client which has
                    previously been requested to shutdown, it will
                    automatically escalate and force shutdown.
                  • is_stopped() Checks whether a client is stopped. Returns:
                    true if the client is fully stopped.
                  • on_attach(client, bufnr) Runs the on_attach function from
                    the client's config if it was defined. Useful for
                    buffer-local setup.

                • Members
                  • {id} (number): The id allocated to the client.
                  • {name} (string): If a name is specified on creation, that
                    will be used. Otherwise it is just the client id. This is
                    used for logs and messages.
                  • {rpc} (table): RPC client object, for low level
                    interaction with the client. See |vim.lsp.rpc.start()|.
                  • {offset_encoding} (string): The encoding used for
                    communicating with the server. You can modify this in the
                    `config` 's `on_init` method before text is sent to the
                    server.
                  • {handlers} (table): The handlers used by the client as
                    described in |lsp-handler|.
                  • {config} (table): copy of the table that was passed by the
                    user to |vim.lsp.start_client()|.
                  • {server_capabilities} (table): Response from the server
                    sent on `initialize` describing the server's capabilities.
                  • {resolved_capabilities} (table): Normalized table of
                    capabilities that we have detected based on the initialize
                    response from the server in `server_capabilities` .

client_is_stopped({client_id})                   *vim.lsp.client_is_stopped()*
                Checks whether a client is stopped.

                Parameters: ~
                    {client_id}  (Number)

                Return: ~
                    true if client is stopped, false otherwise.

get_active_clients()                            *vim.lsp.get_active_clients()*
                Gets all active clients.

                Return: ~
                    Table of |vim.lsp.client| objects

                                          *vim.lsp.get_buffers_by_client_id()*
get_buffers_by_client_id({client_id})
                Parameters: ~
                    {client_id}  client id

                Return: ~
                    list of buffer ids

get_client_by_id({client_id})                     *vim.lsp.get_client_by_id()*
                Gets a client by id, or nil if the id is invalid. The returned
                client may not yet be fully initialized.

                Parameters: ~
                    {client_id}  client id number

                Return: ~
                    |vim.lsp.client| object, or nil

get_log_path()                                        *vim.lsp.get_log_path()*
                Gets the path of the logfile used by the LSP client.

                Return: ~
                    (String) Path to logfile.

omnifunc({findstart}, {base})                             *vim.lsp.omnifunc()*
                Implements 'omnifunc' compatible LSP completion.

                Parameters: ~
                    {findstart}  0 or 1, decides behavior
                    {base}       If findstart=0, text to match against

                Return: ~
                    (number) Decided by`findstart`:
                    • findstart=0: column where the completion starts, or -2
                      or -3
                    • findstart=1: list of matches (actually just calls
                      |complete()|)

                See also: ~
                    |complete-functions|
                    |complete-items|
                    |CompleteDone|

set_log_level({level})                               *vim.lsp.set_log_level()*
                Sets the global log level for LSP logging.

                Levels by name: "trace", "debug", "info", "warn", "error"
                Level numbers begin with "trace" at 0

                Use `lsp.log_levels` for reverse lookup.

                Parameters: ~
                    {level}  [number|string] the case insensitive level name
                             or number

                See also: ~
                    |vim.lsp.log_levels|

start_client({config})                                *vim.lsp.start_client()*
                Starts and initializes a client with the given configuration.

                Parameters `cmd` and `root_dir` are required.

                The following parameters describe fields in the {config}
                table.

                Parameters: ~
                    {root_dir}         (required, string) Directory where the
                                       LSP server will base its rootUri on
                                       initialization.
                    {cmd}              (required, string or list treated like
                                       |jobstart()|) Base command that
                                       initiates the LSP client.
                    {cmd_cwd}          (string, default=|getcwd()|) Directory
                                       to launch the `cmd` process. Not
                                       related to `root_dir` .
                    {cmd_env}          (table) Environment flags to pass to
                                       the LSP on spawn. Can be specified
                                       using keys like a map or as a list with `k=v` pairs or both. Non-string values are
                                       coerced to string. Example: >

                 { "PRODUCTION=true"; "TEST=123"; PORT = 8080; HOST = "0.0.0.0"; }
<
                    {capabilities}     Map overriding the default capabilities
                                       defined by
                                       |vim.lsp.protocol.make_client_capabilities()|,
                                       passed to the language server on
                                       initialization. Hint: use
                                       make_client_capabilities() and modify
                                       its result.
                                       • Note: To send an empty dictionary use
                                         `{[vim.type_idx]=vim.types.dictionary}`
                                         , else it will be encoded as an
                                         array.
                    {handlers}         Map of language server method names to
                                       |lsp-handler|
                    {settings}         Map with language server specific
                                       settings. These are returned to the
                                       language server if requested via
                                       `workspace/configuration` . Keys are
                                       case-sensitive.
                    {init_options}     Values to pass in the initialization
                                       request as `initializationOptions` .
                                       See `initialize` in the LSP spec.
                    {name}             (string, default=client-id) Name in log
                                       messages.
                    {get_language_id}  function(bufnr, filetype) -> language
                                       ID as string. Defaults to the filetype.
                    {offset_encoding}  (default="utf-16") One of "utf-8",
                                       "utf-16", or "utf-32" which is the
                                       encoding that the LSP server expects.
                                       Client does not verify this is correct.
                    {on_error}         Callback with parameters (code, ...),
                                       invoked when the client operation
                                       throws an error. `code` is a number
                                       describing the error. Other arguments
                                       may be passed depending on the error
                                       kind. See |vim.lsp.client_errors| for
                                       possible errors. Use
                                       `vim.lsp.client_errors[code]` to get
                                       human-friendly name.
                    {before_init}      Callback with parameters
                                       (initialize_params, config) invoked
                                       before the LSP "initialize" phase,
                                       where `params` contains the parameters
                                       being sent to the server and `config`
                                       is the config that was passed to
                                       |vim.lsp.start_client()|. You can use
                                       this to modify parameters before they
                                       are sent.
                    {on_init}          Callback (client, initialize_result)
                                       invoked after LSP "initialize", where
                                       `result` is a table of `capabilities`
                                       and anything else the server may send.
                                       For example, clangd sends
                                       `initialize_result.offsetEncoding` if
                                       `capabilities.offsetEncoding` was sent
                                       to it. You can only modify the
                                       `client.offset_encoding` here before
                                       any notifications are sent. Most
                                       language servers expect to be sent
                                       client specified settings after
                                       initialization. Neovim does not make
                                       this assumption. A
                                       `workspace/didChangeConfiguration`
                                       notification should be sent to the
                                       server during on_init.
                    {on_exit}          Callback (code, signal, client_id)
                                       invoked on client exit.
                                       • code: exit code of the process
                                       • signal: number describing the signal
                                         used to terminate (if any)
                                       • client_id: client handle
                    {on_attach}        Callback (client, bufnr) invoked when
                                       client attaches to a buffer.
                    {trace}            "off" | "messages" | "verbose" | nil
                                       passed directly to the language server
                                       in the initialize request.
                                       Invalid/empty values will default to
                                       "off"
                    {flags}            A table with flags for the client. The
                                       current (experimental) flags are:
                                       • allow_incremental_sync (bool, default
                                         true): Allow using incremental sync
                                         for buffer edits

                Return: ~
                    Client id. |vim.lsp.get_client_by_id()| Note: client may
                    not be fully initialized. Use `on_init` to do any actions
                    once the client has been initialized.

stop_client({client_id}, {force})                      *vim.lsp.stop_client()*
                Stops a client(s).

                You can also use the `stop()` function on a |vim.lsp.client|
                object. To stop all clients:
>

    vim.lsp.stop_client(vim.lsp.get_active_clients())
<

                By default asks the server to shutdown, unless stop was
                requested already for this client, then force-shutdown is
                attempted.

                Parameters: ~
                    {client_id}  client id or |vim.lsp.client| object, or list
                                 thereof
                    {force}      boolean (optional) shutdown forcefully

with({handler}, {override_config})                            *vim.lsp.with()*
                Function to manage overriding defaults for LSP handlers.

                Parameters: ~
                    {handler}          (function) See |lsp-handler|
                    {override_config}  (table) Table containing the keys to
                                       override behavior of the {handler}


==============================================================================
Lua module: vim.lsp.buf                                              *lsp-buf*

                                          *vim.lsp.buf.add_workspace_folder()*
add_workspace_folder({workspace_folder})
                Add the folder at path to the workspace folders. If {path} is
                not provided, the user will be prompted for a path using
                |input()|.

clear_references()                            *vim.lsp.buf.clear_references()*
                Removes document highlights from current buffer.

code_action({context})                             *vim.lsp.buf.code_action()*
                Selects a code action from the input list that is available at
                the current cursor position.

                Parameters: ~
                    {context}  (table, optional) Valid `CodeActionContext`
                               object

                See also: ~
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_codeAction

completion({context})                               *vim.lsp.buf.completion()*
                Retrieves the completion items at the current cursor position.
                Can only be called in Insert mode.

                Parameters: ~
                    {context}  (context support not yet implemented)
                               Additional information about the context in
                               which a completion was triggered (how it was
                               triggered, and by which trigger character, if
                               applicable)

                See also: ~
                    |vim.lsp.protocol.constants.CompletionTriggerKind|

declaration()                                      *vim.lsp.buf.declaration()*
                Jumps to the declaration of the symbol under the cursor.
                Note:
                    Many servers do not implement this method. Generally, see
                    |vim.lsp.buf.definition()| instead.

definition()                                        *vim.lsp.buf.definition()*
                Jumps to the definition of the symbol under the cursor.

document_highlight()                        *vim.lsp.buf.document_highlight()*
                Send request to the server to resolve document highlights for
                the current text document position. This request can be
                triggered by a key mapping or by events such as `CursorHold` ,
                eg:
>
    vim.api.nvim_command [[autocmd CursorHold  <buffer> lua vim.lsp.buf.document_highlight()]]
    vim.api.nvim_command [[autocmd CursorHoldI <buffer> lua vim.lsp.buf.document_highlight()]]
    vim.api.nvim_command [[autocmd CursorMoved <buffer> lua vim.lsp.buf.clear_references()]]
<

                Note: Usage of |vim.lsp.buf.document_highlight()| requires the
                following highlight groups to be defined or you won't be able
                to see the actual highlights. |LspReferenceText|
                |LspReferenceRead| |LspReferenceWrite|

document_symbol()                              *vim.lsp.buf.document_symbol()*
                Lists all symbols in the current buffer in the quickfix
                window.

execute_command({command})                     *vim.lsp.buf.execute_command()*
                Executes an LSP server command.

                Parameters: ~
                    {command}  A valid `ExecuteCommandParams` object

                See also: ~
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_executeCommand

formatting({options})                               *vim.lsp.buf.formatting()*
                Formats the current buffer.

                Parameters: ~
                    {options}  (optional, table) Can be used to specify
                               FormattingOptions. Some unspecified options
                               will be automatically derived from the current
                               Neovim options.

                See also: ~
                    https://microsoft.github.io/language-server-protocol/specification#textDocument_formatting

                                               *vim.lsp.buf.formatting_sync()*
formatting_sync({options}, {timeout_ms})
                Performs |vim.lsp.buf.formatting()| synchronously.

                Useful for running on save, to make sure buffer is formatted
                prior to being saved. {timeout_ms} is passed on to
                |vim.lsp.buf_request_sync()|. Example:
>

    vim.api.nvim_command[[autocmd BufWritePre <buffer> lua vim.lsp.buf.formatting_sync()]]
<

                Parameters: ~
                    {options}     Table with valid `FormattingOptions` entries
                    {timeout_ms}  (number) Request timeout

hover()                                                  *vim.lsp.buf.hover()*
                Displays hover information about the symbol under the cursor
                in a floating window. Calling the function twice will jump
                into the floating window.

implementation()                                *vim.lsp.buf.implementation()*
                Lists all the implementations for the symbol under the cursor
                in the quickfix window.

incoming_calls()                                *vim.lsp.buf.incoming_calls()*
                Lists all the call sites of the symbol under the cursor in the
                |quickfix| window. If the symbol can resolve to multiple
                items, the user can pick one in the |inputlist|.

list_workspace_folders()                *vim.lsp.buf.list_workspace_folders()*
                List workspace folders.

outgoing_calls()                                *vim.lsp.buf.outgoing_calls()*
                Lists all the items that are called by the symbol under the
                cursor in the |quickfix| window. If the symbol can resolve to
                multiple items, the user can pick one in the |inputlist|.

                                             *vim.lsp.buf.range_code_action()*
range_code_action({context}, {start_pos}, {end_pos})
                Performs |vim.lsp.buf.code_action()| for a given range.

                Parameters: ~
                    {context}    (table, optional) Valid `CodeActionContext`
                                 object
                    {start_pos}  ({number, number}, optional) mark-indexed
                                 position. Defaults to the start of the last
                                 visual selection.
                    {end_pos}    ({number, number}, optional) mark-indexed
                                 position. Defaults to the end of the last
                                 visual selection.

                                              *vim.lsp.buf.range_formatting()*
range_formatting({options}, {start_pos}, {end_pos})
                Formats a given range.

                Parameters: ~
                    {options}    Table with valid `FormattingOptions` entries.
                    {start_pos}  ({number, number}, optional) mark-indexed
                                 position. Defaults to the start of the last
                                 visual selection.
                    {end_pos}    ({number, number}, optional) mark-indexed
                                 position. Defaults to the end of the last
                                 visual selection.

references({context})                               *vim.lsp.buf.references()*
                Lists all the references to the symbol under the cursor in the
                quickfix window.

                Parameters: ~
                    {context}  (table) Context for the request

                See also: ~
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_references

                                       *vim.lsp.buf.remove_workspace_folder()*
remove_workspace_folder({workspace_folder})
                Remove the folder at path from the workspace folders. If
                {path} is not provided, the user will be prompted for a path
                using |input()|.

rename({new_name})                                      *vim.lsp.buf.rename()*
                Renames all references to the symbol under the cursor.

                Parameters: ~
                    {new_name}  (string) If not provided, the user will be
                                prompted for a new name using |input()|.

server_ready()                                    *vim.lsp.buf.server_ready()*
                Checks whether the language servers attached to the current
                buffer are ready.

                Return: ~
                    `true` if server responds.

signature_help()                                *vim.lsp.buf.signature_help()*
                Displays signature information about the symbol under the
                cursor in a floating window.

type_definition()                              *vim.lsp.buf.type_definition()*
                Jumps to the definition of the type of the symbol under the
                cursor.

workspace_symbol({query})                     *vim.lsp.buf.workspace_symbol()*
                Lists all symbols in the current workspace in the quickfix
                window.

                The list is filtered against {query}; if the argument is
                omitted from the call, the user is prompted to enter a string
                on the command line. An empty string means no filtering is
                done.

                Parameters: ~
                    {query}  (string, optional)


==============================================================================
Lua module: vim.lsp.diagnostic                                *lsp-diagnostic*

                                                  *vim.lsp.diagnostic.clear()*
clear({bufnr}, {client_id}, {diagnostic_ns}, {sign_ns})
                Clears the currently displayed diagnostics

                Parameters: ~
                    {bufnr}          number The buffer number
                    {client_id}      number the client id
                    {diagnostic_ns}  number|nil Associated diagnostic
                                     namespace
                    {sign_ns}        number|nil Associated sign namespace

get({bufnr}, {client_id})                           *vim.lsp.diagnostic.get()*
                Return associated diagnostics for bufnr

                Parameters: ~
                    {bufnr}      number
                    {client_id}  number|nil If nil, then return all of the
                                 diagnostics. Else, return just the
                                 diagnostics associated with the client_id.

get_all()                                       *vim.lsp.diagnostic.get_all()*
                Get all diagnostics for all clients

                Return: ~
                    {bufnr:Diagnostic[]}

                                              *vim.lsp.diagnostic.get_count()*
get_count({bufnr}, {severity}, {client_id})
                Get the counts for a particular severity

                Useful for showing diagnostic counts in statusline. eg:
>

    function! LspStatus() abort
      let sl = ''
      if luaeval('not vim.tbl_isempty(vim.lsp.buf_get_clients(0))')
        let sl.='%#MyStatuslineLSP#E:'
        let sl.='%#MyStatuslineLSPErrors#%{luaeval("vim.lsp.diagnostic.get_count(0, [[Error]])")}'
        let sl.='%#MyStatuslineLSP# W:'
        let sl.='%#MyStatuslineLSPWarnings#%{luaeval("vim.lsp.diagnostic.get_count(0, [[Warning]])")}'
      else
          let sl.='%#MyStatuslineLSPErrors#off'
      endif
      return sl
    endfunction
    let &l:statusline = '%#MyStatuslineLSP#LSP '.LspStatus()
<

                Parameters: ~
                    {bufnr}      number The buffer number
                    {severity}   DiagnosticSeverity
                    {client_id}  number the client id

                                   *vim.lsp.diagnostic.get_line_diagnostics()*
get_line_diagnostics({bufnr}, {line_nr}, {opts}, {client_id})
                Get the diagnostics by line

                Parameters: ~
                    {bufnr}      number The buffer number
                    {line_nr}    number The line number
                    {opts}       table|nil Configuration keys
                                 • severity: (DiagnosticSeverity, default nil)
                                   • Only return diagnostics with this
                                     severity. Overrides severity_limit

                                 • severity_limit: (DiagnosticSeverity, default nil)
                                   • Limit severity of diagnostics found. E.g.
                                     "Warning" means { "Error", "Warning" }
                                     will be valid.
                    {client_id}  number the client id

                Return: ~
                    table Table with map of line number to list of
                    diagnostics.

get_next({opts})                               *vim.lsp.diagnostic.get_next()*
                Get the next diagnostic closest to the cursor_position

                Parameters: ~
                    {opts}  table See |vim.lsp.diagnostic.goto_next()|

                Return: ~
                    table Next diagnostic

get_next_pos({opts})                       *vim.lsp.diagnostic.get_next_pos()*
                Return the pos, {row, col}, for the next diagnostic in the
                current buffer.

                Parameters: ~
                    {opts}  table See |vim.lsp.diagnostic.goto_next()|

                Return: ~
                    table Next diagnostic position

get_prev({opts})                               *vim.lsp.diagnostic.get_prev()*
                Get the previous diagnostic closest to the cursor_position

                Parameters: ~
                    {opts}  table See |vim.lsp.diagnostic.goto_next()|

                Return: ~
                    table Previous diagnostic

get_prev_pos({opts})                       *vim.lsp.diagnostic.get_prev_pos()*
                Return the pos, {row, col}, for the prev diagnostic in the
                current buffer.

                Parameters: ~
                    {opts}  table See |vim.lsp.diagnostic.goto_next()|

                Return: ~
                    table Previous diagnostic position

                       *vim.lsp.diagnostic.get_virtual_text_chunks_for_line()*
get_virtual_text_chunks_for_line({bufnr}, {line}, {line_diags}, {opts})
                Default function to get text chunks to display using `nvim_buf_set_virtual_text` .

                Parameters: ~
                    {bufnr}       number The buffer to display the virtual
                                  text in
                    {line}        number The line number to display the
                                  virtual text on
                    {line_diags}  Diagnostic [] The diagnostics associated with the line
                    {opts}        table See {opts} from
                                  |vim.lsp.diagnostic.set_virtual_text()|

                Return: ~
                    table chunks, as defined by |nvim_buf_set_virtual_text()|

goto_next({opts})                             *vim.lsp.diagnostic.goto_next()*
                Move to the next diagnostic

                Parameters: ~
                    {opts}  table|nil Configuration table. Keys:
                            • {client_id}: (number)
                              • If nil, will consider all clients attached to
                                buffer.

                            • {cursor_position}: (Position, default current
                              position)
                              • See |nvim_win_get_cursor()|

                            • {wrap}: (boolean, default true)
                              • Whether to loop around file or not. Similar to
                                'wrapscan'

                            • {severity}: (DiagnosticSeverity)
                              • Exclusive severity to consider. Overrides
                                {severity_limit}

                            • {severity_limit}: (DiagnosticSeverity)
                              • Limit severity of diagnostics found. E.g.
                                "Warning" means { "Error", "Warning" } will be
                                valid.

                            • {enable_popup}: (boolean, default true)
                              • Call
                                |vim.lsp.diagnostic.show_line_diagnostics()|
                                on jump

                            • {popup_opts}: (table)
                              • Table to pass as {opts} parameter to
                                |vim.lsp.diagnostic.show_line_diagnostics()|

                            • {win_id}: (number, default 0)
                              • Window ID

goto_prev({opts})                             *vim.lsp.diagnostic.goto_prev()*
                Move to the previous diagnostic

                Parameters: ~
                    {opts}  table See |vim.lsp.diagnostic.goto_next()|

                                 *vim.lsp.diagnostic.on_publish_diagnostics()*
on_publish_diagnostics({_}, {_}, {params}, {client_id}, {_}, {config})
                |lsp-handler| for the method "textDocument/publishDiagnostics"

                Note:
                    Each of the configuration options accepts:
                    • `false` : Disable this feature
                    • `true` : Enable this feature, use default settings.
                    • `table` : Enable this feature, use overrides.
                    • `function`: Function with signature (bufnr, client_id) that
                      returns any of the above.>

                 vim.lsp.handlers["textDocument/publishDiagnostics"] = vim.lsp.with(
                   vim.lsp.diagnostic.on_publish_diagnostics, {
                     -- Enable underline, use default values
                     underline = true,
                     -- Enable virtual text, override spacing to 4
                     virtual_text = {
                       spacing = 4,
                     },
                     -- Use a function to dynamically turn signs off
                     -- and on, using buffer local variables
                     signs = function(bufnr, client_id)
                       return vim.bo[bufnr].show_signs == false
                     end,
                     -- Disable a feature
                     update_in_insert = false,
                   }
                 )
<

                Parameters: ~
                    {config}  table Configuration table.
                              • underline: (default=true)
                                • Apply underlines to diagnostics.
                                • See |vim.lsp.diagnostic.set_underline()|

                              • virtual_text: (default=true)
                                • Apply virtual text to line endings.
                                • See |vim.lsp.diagnostic.set_virtual_text()|

                              • signs: (default=true)
                                • Apply signs for diagnostics.
                                • See |vim.lsp.diagnostic.set_signs()|

                              • update_in_insert: (default=false)
                                • Update diagnostics in InsertMode or wait
                                  until InsertLeave

reset({client_id}, {buffer_client_map})           *vim.lsp.diagnostic.reset()*
                Clear diagnotics and diagnostic cache

                Handles saving diagnostics from multiple clients in the same
                buffer.

                Parameters: ~
                    {client_id}          number
                    {buffer_client_map}  table map of buffers to active
                                         clients

save({diagnostics}, {bufnr}, {client_id})          *vim.lsp.diagnostic.save()*
                Save diagnostics to the current buffer.

                Handles saving diagnostics from multiple clients in the same
                buffer.

                Parameters: ~
                    {diagnostics}  Diagnostic []
                    {bufnr}        number
                    {client_id}    number

set_loclist({opts})                         *vim.lsp.diagnostic.set_loclist()*
                Sets the location list

                Parameters: ~
                    {opts}  table|nil Configuration table. Keys:
                            • {open_loclist}: (boolean, default true)
                              • Open loclist after set

                            • {client_id}: (number)
                              • If nil, will consider all clients attached to
                                buffer.

                            • {severity}: (DiagnosticSeverity)
                              • Exclusive severity to consider. Overrides
                                {severity_limit}

                            • {severity_limit}: (DiagnosticSeverity)
                              • Limit severity of diagnostics found. E.g.
                                "Warning" means { "Error", "Warning" } will be
                                valid.

                                              *vim.lsp.diagnostic.set_signs()*
set_signs({diagnostics}, {bufnr}, {client_id}, {sign_ns}, {opts})
                Set signs for given diagnostics

                Sign characters can be customized with the following commands:
>

    sign define LspDiagnosticsSignError text=E texthl=LspDiagnosticsSignError linehl= numhl=
    sign define LspDiagnosticsSignWarning text=W texthl=LspDiagnosticsSignWarning linehl= numhl=
    sign define LspDiagnosticsSignInformation text=I texthl=LspDiagnosticsSignInformation linehl= numhl=
    sign define LspDiagnosticsSignHint text=H texthl=LspDiagnosticsSignHint linehl= numhl=
<

                Parameters: ~
                    {diagnostics}  Diagnostic []
                    {bufnr}        number The buffer number
                    {client_id}    number the client id
                    {sign_ns}      number|nil
                    {opts}         table Configuration for signs. Keys:
                                   • priority: Set the priority of the signs.
                                   • severity_limit (DiagnosticSeverity):
                                     • Limit severity of diagnostics found.
                                       E.g. "Warning" means { "Error",
                                       "Warning" } will be valid.

                                          *vim.lsp.diagnostic.set_underline()*
set_underline({diagnostics}, {bufnr}, {client_id}, {diagnostic_ns}, {opts})
                Set underline for given diagnostics

                Underline highlights can be customized by changing the
                following |:highlight| groups.
>

    LspDiagnosticsUnderlineError
    LspDiagnosticsUnderlineWarning
    LspDiagnosticsUnderlineInformation
    LspDiagnosticsUnderlineHint
<

                Parameters: ~
                    {diagnostics}    Diagnostic []
                    {bufnr}          number: The buffer number
                    {client_id}      number: The client id
                    {diagnostic_ns}  number|nil: The namespace
                    {opts}           table: Configuration table:
                                     • severity_limit (DiagnosticSeverity):
                                       • Limit severity of diagnostics found.
                                         E.g. "Warning" means { "Error",
                                         "Warning" } will be valid.

                                       *vim.lsp.diagnostic.set_virtual_text()*
set_virtual_text({diagnostics}, {bufnr}, {client_id}, {diagnostic_ns}, {opts})
                Set virtual text given diagnostics

                Virtual text highlights can be customized by changing the
                following |:highlight| groups.
>

    LspDiagnosticsVirtualTextError
    LspDiagnosticsVirtualTextWarning
    LspDiagnosticsVirtualTextInformation
    LspDiagnosticsVirtualTextHint
<

                Parameters: ~
                    {diagnostics}    Diagnostic []
                    {bufnr}          number
                    {client_id}      number
                    {diagnostic_ns}  number
                    {opts}           table Options on how to display virtual
                                     text. Keys:
                                     • prefix (string): Prefix to display
                                       before virtual text on line
                                     • spacing (number): Number of spaces to
                                       insert before virtual text
                                     • severity_limit (DiagnosticSeverity):
                                       • Limit severity of diagnostics found.
                                         E.g. "Warning" means { "Error",
                                         "Warning" } will be valid.

                                  *vim.lsp.diagnostic.show_line_diagnostics()*
show_line_diagnostics({opts}, {bufnr}, {line_nr}, {client_id})
                Open a floating window with the diagnostics from {line_nr}

                The floating window can be customized with the following
                highlight groups: >

                 LspDiagnosticsFloatingError
                 LspDiagnosticsFloatingWarning
                 LspDiagnosticsFloatingInformation
                 LspDiagnosticsFloatingHint
<

                Parameters: ~
                    {opts}       table Configuration table
                                 • show_header (boolean, default true): Show
                                   "Diagnostics:" header.
                    {bufnr}      number The buffer number
                    {line_nr}    number The line number
                    {client_id}  number|nil the client id

                Return: ~
                    table {popup_bufnr, win_id}


==============================================================================
Lua module: vim.lsp.handlers                                    *lsp-handlers*

                                         *vim.lsp.handlers.progress_handler()*
progress_handler({_}, {_}, {params}, {client_id})
                See also: ~
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#workspace_executeCommand


==============================================================================
Lua module: vim.lsp.util                                            *lsp-util*

                                     *vim.lsp.util.apply_text_document_edit()*
apply_text_document_edit({text_document_edit}, {index})
                Applies a `TextDocumentEdit` , which is a list of changes to a
                single document.

                Parameters: ~
                    {text_document_edit}  table: a `TextDocumentEdit` object
                    {index}               number: Optional index of the edit,
                                          if from a list of edits (or nil, if
                                          not from a list)

                See also: ~
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentEdit

                                             *vim.lsp.util.apply_text_edits()*
apply_text_edits({text_edits}, {bufnr})
                Applies a list of text edits to a buffer.

                Parameters: ~
                    {text_edits}  (table) list of `TextEdit` objects
                    {buf_nr}      (number) Buffer id

                                         *vim.lsp.util.apply_workspace_edit()*
apply_workspace_edit({workspace_edit})
                Applies a `WorkspaceEdit` .

                Parameters: ~
                    {workspace_edit}  (table) `WorkspaceEdit`

buf_clear_references({bufnr})            *vim.lsp.util.buf_clear_references()*
                Removes document highlights from a buffer.

                Parameters: ~
                    {bufnr}  buffer id

                                     *vim.lsp.util.buf_highlight_references()*
buf_highlight_references({bufnr}, {references})
                Shows a list of document highlights for a certain buffer.

                Parameters: ~
                    {bufnr}       buffer id
                    {references}  List of `DocumentHighlight` objects to
                                  highlight

character_offset({buf}, {row}, {col})        *vim.lsp.util.character_offset()*
                Returns the UTF-32 and UTF-16 offsets for a position in a
                certain buffer.

                Parameters: ~
                    {buf}  buffer id (0 for current)
                    {row}  0-indexed line
                    {col}  0-indexed byte offset in line

                Return: ~
                    (number, number) UTF-32 and UTF-16 index of the character
                    in line {row} column {col} in buffer {buf}

                                        *vim.lsp.util.close_preview_autocmd()*
close_preview_autocmd({events}, {winnr})
                Creates autocommands to close a preview window when events
                happen.

                Parameters: ~
                    {events}  (table) list of events
                    {winnr}   (number) window id of preview window

                See also: ~
                    |autocmd-events|

                                                 *vim.lsp.util.compute_diff()*
compute_diff({old_lines}, {new_lines}, {start_line_idx}, {end_line_idx})
                Returns the range table for the difference between old and new
                lines

                Parameters: ~
                    {old_lines}  table list of lines
                    {new_lines}  table list of lines

                Return: ~
                    table start_line_idx and start_col_idx of range

                              *vim.lsp.util.convert_input_to_markdown_lines()*
convert_input_to_markdown_lines({input}, {contents})
                Converts any of `MarkedString` | `MarkedString[]` |
                `MarkupContent` into a list of lines containing valid
                markdown. Useful to populate the hover window for
                `textDocument/hover` , for parsing the result of
                `textDocument/signatureHelp` , and potentially others.

                Parameters: ~
                    {input}     ( `MarkedString` | `MarkedString[]` |
                                `MarkupContent` )
                    {contents}  (table, optional, default `{}` ) List of
                                strings to extend with converted lines

                Return: ~
                    {contents}, extended with lines of converted markdown.

                See also: ~
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_hover

                     *vim.lsp.util.convert_signature_help_to_markdown_lines()*
convert_signature_help_to_markdown_lines({signature_help})
                Converts `textDocument/SignatureHelp` response to markdown
                lines.

                Parameters: ~
                    {signature_help}  Response of `textDocument/SignatureHelp`

                Return: ~
                    list of lines of converted markdown.

                See also: ~
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_signatureHelp

                                     *vim.lsp.util.extract_completion_items()*
extract_completion_items({result})
                Can be used to extract the completion items from a `textDocument/completion` request, which may return one of `CompletionItem[]` , `CompletionList` or null.

                Parameters: ~
                    {result}  (table) The result of a
                              `textDocument/completion` request

                Return: ~
                    (table) List of completion items

                See also: ~
                    https://microsoft.github.io/language-server-protocol/specification#textDocument_completion

                                      *vim.lsp.util.fancy_floating_markdown()*
fancy_floating_markdown({contents}, {opts})
                Converts markdown into syntax highlighted regions by stripping
                the code blocks and converting them into highlighted code.
                This will by default insert a blank line separator after those
                code block regions to improve readability. The result is shown
                in a floating preview.

                Parameters: ~
                    {contents}  table of lines to show in window
                    {opts}      dictionary with optional fields
                                • height of floating window
                                • width of floating window
                                • wrap_at character to wrap at for computing
                                  height
                                • max_width maximal width of floating window
                                • max_height maximal height of floating window
                                • pad_left number of columns to pad contents
                                  at left
                                • pad_right number of columns to pad contents
                                  at right
                                • pad_top number of lines to pad contents at
                                  top
                                • pad_bottom number of lines to pad contents
                                  at bottom
                                • separator insert separator after code block

                Return: ~
                    width,height size of float

focusable_float({unique_name}, {fn})          *vim.lsp.util.focusable_float()*
                Parameters: ~
                    {unique_name}  (string) Window variable
                    {fn}           (function) should return create a new
                                   window and return a tuple of
                                   ({focusable_buffer_id}, {window_id}). if
                                   {focusable_buffer_id} is a valid buffer id,
                                   the newly created window will be the new
                                   focus associated with the current buffer
                                   via the tag `unique_name` .

                Return: ~
                    (pbufnr, pwinnr) if `fn()` has created a new window; nil
                    otherwise

                                            *vim.lsp.util.focusable_preview()*
focusable_preview({unique_name}, {fn})
                Focuses/unfocuses the floating preview window associated with
                the current buffer via the window variable `unique_name` . If
                no such preview window exists, makes a new one.

                Parameters: ~
                    {unique_name}  (string) Window variable
                    {fn}           (function) The return values of this
                                   function will be passed directly to
                                   |vim.lsp.util.open_floating_preview()|, in
                                   the case that a new floating window should
                                   be created

get_effective_tabstop({bufnr})          *vim.lsp.util.get_effective_tabstop()*
                Returns visual width of tabstop.

                Parameters: ~
                    {bufnr}  (optional, number): Buffer handle, defaults to
                             current

                Return: ~
                    (number) tabstop visual width

                See also: ~
                    |softtabstop|

get_progress_messages()                 *vim.lsp.util.get_progress_messages()*
                TODO: Documentation

jump_to_location({location})                 *vim.lsp.util.jump_to_location()*
                Jumps to a location.

                Parameters: ~
                    {location}  ( `Location` | `LocationLink` )

                Return: ~
                    `true` if the jump succeeded

locations_to_items({locations})            *vim.lsp.util.locations_to_items()*
                Returns the items with the byte position calculated correctly
                and in sorted order, for display in quickfix and location
                lists.

                Parameters: ~
                    {locations}  (table) list of `Location` s or
                                 `LocationLink` s

                Return: ~
                    (table) list of items

lookup_section({settings}, {section})          *vim.lsp.util.lookup_section()*
                Helper function to return nested values in language server
                settings

                Parameters: ~
                    {settings}  a table of language server settings
                    {section}   a string indicating the field of the settings
                                table

                Return: ~
                    (table or string) The value of settings accessed via
                    section

                                  *vim.lsp.util.make_floating_popup_options()*
make_floating_popup_options({width}, {height}, {opts})
                Creates a table with sensible default options for a floating
                window. The table can be passed to |nvim_open_win()|.

                Parameters: ~
                    {width}   (number) window width (in character cells)
                    {height}  (number) window height (in character cells)
                    {opts}    (table, optional)

                Return: ~
                    (table) Options

                                       *vim.lsp.util.make_formatting_params()*
make_formatting_params({options})
                Creates a `FormattingOptions` object for the current buffer
                and cursor position.

                Parameters: ~
                    {options}  Table with valid `FormattingOptions` entries

                Return: ~
                    `FormattingOptions object

                See also: ~
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_formatting

                                      *vim.lsp.util.make_given_range_params()*
make_given_range_params({start_pos}, {end_pos})
                Using the given range in the current buffer, creates an object
                that is similar to |vim.lsp.util.make_range_params()|.

                Parameters: ~
                    {start_pos}  ({number, number}, optional) mark-indexed
                                 position. Defaults to the start of the last
                                 visual selection.
                    {end_pos}    ({number, number}, optional) mark-indexed
                                 position. Defaults to the end of the last
                                 visual selection.

                Return: ~
                    { textDocument = { uri = `current_file_uri` }, range = {
                    start = `start_position` , end = `end_position` } }

make_position_params()                   *vim.lsp.util.make_position_params()*
                Creates a `TextDocumentPositionParams` object for the current
                buffer and cursor position.

                Return: ~
                    `TextDocumentPositionParams` object

                See also: ~
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentPositionParams

make_range_params()                         *vim.lsp.util.make_range_params()*
                Using the current position in the current buffer, creates an
                object that can be used as a building block for several LSP
                requests, such as `textDocument/codeAction` ,
                `textDocument/colorPresentation` ,
                `textDocument/rangeFormatting` .

                Return: ~
                    { textDocument = { uri = `current_file_uri` }, range = {
                    start = `current_position` , end = `current_position` } }

make_text_document_params()         *vim.lsp.util.make_text_document_params()*
                Creates a `TextDocumentIdentifier` object for the current
                buffer.

                Return: ~
                    `TextDocumentIdentifier`

                See also: ~
                    https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocumentIdentifier

                                        *vim.lsp.util.make_workspace_params()*
make_workspace_params({added}, {removed})
                Create the workspace params

                Parameters: ~
                    {added}    
                    {removed}

                                        *vim.lsp.util.open_floating_preview()*
open_floating_preview({contents}, {filetype}, {opts})
                Shows contents in a floating window.

                Parameters: ~
                    {contents}  table of lines to show in window
                    {filetype}  string of filetype to set for opened buffer
                    {opts}      dictionary with optional fields

                Return: ~
                    bufnr,winnr buffer and window number of the newly created
                    floating preview window

parse_snippet({input})                          *vim.lsp.util.parse_snippet()*
                Parses snippets in a completion entry.

                Parameters: ~
                    {input}  (string) unparsed snippet

                Return: ~
                    (string) parsed snippet

preview_location({location})                 *vim.lsp.util.preview_location()*
                Previews a location in a floating window

                behavior depends on type of location:
                • for Location, range is shown (e.g., function definition)
                • for LocationLink, targetRange is shown (e.g., body of
                  function definition)

                Parameters: ~
                    {location}  a single `Location` or `LocationLink`

                Return: ~
                    (bufnr,winnr) buffer and window number of floating window
                    or nil

set_lines({lines}, {A}, {B}, {new_lines})           *vim.lsp.util.set_lines()*
                Replaces text in a range with new text.

                CAUTION: Changes in-place!

                Parameters: ~
                    {lines}      (table) Original list of strings
                    {A}          (table) Start position; a 2-tuple of {line,
                                 col} numbers
                    {B}          (table) End position; a 2-tuple of {line,
                                 col} numbers
                    {new_lines}  A list of strings to replace the original

                Return: ~
                    (table) The modified {lines} object

set_loclist({items})                              *vim.lsp.util.set_loclist()*
                Fills current window's location list with given list of items.
                Can be obtained with e.g. |vim.lsp.util.locations_to_items()|.

                Parameters: ~
                    {items}  (table) list of items

set_qflist({items})                                *vim.lsp.util.set_qflist()*
                Fills quickfix list with given list of items. Can be obtained
                with e.g. |vim.lsp.util.locations_to_items()|.

                Parameters: ~
                    {items}  (table) list of items

symbols_to_items({symbols}, {bufnr})         *vim.lsp.util.symbols_to_items()*
                Converts symbols to quickfix list items.

                Parameters: ~
                    {symbols}  DocumentSymbol[] or SymbolInformation[]

              *vim.lsp.util.text_document_completion_list_to_complete_items()*
text_document_completion_list_to_complete_items({result}, {prefix})
                Turns the result of a `textDocument/completion` request into
                vim-compatible |complete-items|.

                Parameters: ~
                    {result}  The result of a `textDocument/completion` call,
                              e.g. from |vim.lsp.buf.completion()|, which may
                              be one of `CompletionItem[]` , `CompletionList`
                              or `null`
                    {prefix}  (string) the prefix to filter the completion
                              items

                Return: ~
                    { matches = complete-items table, incomplete = bool }

                See also: ~
                    |complete-items|

trim_empty_lines({lines})                    *vim.lsp.util.trim_empty_lines()*
                Removes empty lines from the beginning and end.

                Parameters: ~
                    {lines}  (table) list of lines to trim

                Return: ~
                    (table) trimmed list of lines

                                *vim.lsp.util.try_trim_markdown_code_blocks()*
try_trim_markdown_code_blocks({lines})
                Accepts markdown lines and tries to reduce them to a filetype
                if they comprise just a single code block.

                CAUTION: Modifies the input in-place!

                Parameters: ~
                    {lines}  (table) list of lines

                Return: ~
                    (string) filetype or 'markdown' if it was unchanged.


==============================================================================
Lua module: vim.lsp.log                                              *lsp-log*

get_filename()                                    *vim.lsp.log.get_filename()*
                Returns the log filename.

                Return: ~
                    (string) log filename

set_level({level})                                   *vim.lsp.log.set_level()*
                Sets the current log level.

                Parameters: ~
                    {level}  (string or number) One of `vim.lsp.log.levels`

should_log({level})                                 *vim.lsp.log.should_log()*
                Checks whether the level is sufficient for logging.

                Parameters: ~
                    {level}  number log level

                Return: ~
                    (bool) true if would log, false if not


==============================================================================
Lua module: vim.lsp.rpc                                              *lsp-rpc*

format_rpc_error({err})                       *vim.lsp.rpc.format_rpc_error()*
                Constructs an error message from an LSP error object.

                Parameters: ~
                    {err}  (table) The error object

                Return: ~
                    (string) The formatted error message

notify({method}, {params})                              *vim.lsp.rpc.notify()*
                Sends a notification to the LSP server.

                Parameters: ~
                    {method}  (string) The invoked LSP method
                    {params}  (table): Parameters for the invoked LSP method

                Return: ~
                    (bool) `true` if notification could be sent, `false` if
                    not

request({method}, {params}, {callback})                *vim.lsp.rpc.request()*
                Sends a request to the LSP server and runs {callback} upon
                response.

                Parameters: ~
                    {method}    (string) The invoked LSP method
                    {params}    (table) Parameters for the invoked LSP method
                    {callback}  (function) Callback to invoke

                Return: ~
                    (bool, number) `(true, message_id)` if request could be
                    sent, `false` if not

                                            *vim.lsp.rpc.rpc_response_error()*
rpc_response_error({code}, {message}, {data})
                Creates an RPC response object/table.

                Parameters: ~
                    {code}     RPC error code defined in
                               `vim.lsp.protocol.ErrorCodes`
                    {message}  (optional) arbitrary message to send to server
                    {data}     (optional) arbitrary data to send to server

                                                         *vim.lsp.rpc.start()*
start({cmd}, {cmd_args}, {dispatchers}, {extra_spawn_params})
                Starts an LSP server process and create an LSP RPC client
                object to interact with it.

                Parameters: ~
                    {cmd}                 (string) Command to start the LSP
                                          server.
                    {cmd_args}            (table) List of additional string
                                          arguments to pass to {cmd}.
                    {dispatchers}         (table, optional) Dispatchers for
                                          LSP message types. Valid dispatcher
                                          names are:
                                          • `"notification"`
                                          • `"server_request"`
                                          • `"on_error"`
                                          • `"on_exit"`
                    {extra_spawn_params}  (table, optional) Additional context
                                          for the LSP server process. May
                                          contain:
                                          • {cwd} (string) Working directory
                                            for the LSP server process
                                          • {env} (table) Additional
                                            environment variables for LSP
                                            server process

                Return: ~
                    Client RPC object.
                    Methods:
                    • `notify()` |vim.lsp.rpc.notify()|
                    • `request()` |vim.lsp.rpc.request()|

                    Members:
                    • {pid} (number) The LSP server's PID.
                    • {handle} A handle for low-level interaction with the LSP
                      server process |vim.loop|.


==============================================================================
Lua module: vim.lsp.protocol                                    *lsp-protocol*

                                 *vim.lsp.protocol.make_client_capabilities()*
make_client_capabilities()
                Gets a new ClientCapabilities object describing the LSP client
                capabilities.

                                     *vim.lsp.protocol.resolve_capabilities()*
resolve_capabilities({server_capabilities})
                `*` to match one or more characters in a path segment `?` to
                match on one character in a path segment `**` to match any
                number of path segments, including none `{}` to group
                conditions (e.g. `**​/*.{ts,js}` matches all TypeScript and
                JavaScript files) `[]` to declare a range of characters to
                match in a path segment (e.g., `example.[0-9]` to match on
                `example.0` , `example.1` , …) `[!...]` to negate a range of
                characters to match in a path segment (e.g., `example.[!0-9]`
                to match on `example.a` , `example.b` , but not `example.0` )

 vim:tw=78:ts=8:ft=help:norl:
