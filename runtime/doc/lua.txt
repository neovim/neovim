*lua.txt*    Nvim


                            NVIM REFERENCE MANUAL


Lua engine                                              *lua* *Lua*

                                      Type |gO| to see the table of contents.

==============================================================================
INTRODUCTION                                            *lua-intro*

The Lua 5.1 language is builtin and always available.  Try this command to get
an idea of what lurks beneath: >

    :lua print(vim.inspect(package.loaded))

Nvim includes a "standard library" |lua-stdlib| for Lua.  It complements the
"editor stdlib" (|builtin-functions| and Ex commands) and the |API|, all of
which can be used from Lua code. A good overview of using Lua in neovim is
given by https://github.com/nanotee/nvim-lua-guide.

The |:source| and |:runtime| commands can run Lua scripts as well as Vim
scripts.  Lua modules can be loaded with `require('name')`, which
conventionally returns a table but can return any value.

See |lua-require| for details on how Nvim finds and loads Lua modules.
See |lua-require-example| for an example of how to write and use a module.

==============================================================================
IMPORTING LUA MODULES                                   *lua-require*

Modules are searched for under the directories specified in 'runtimepath', in
the order they appear.  Any `.` in the module name is treated as a directory
separator when searching.  For a module `foo.bar`, each directory is searched
for `lua/foo/bar.lua`, then `lua/foo/bar/init.lua`.  If no files are found,
the directories are searched again for a shared library with a name matching
`lua/foo/bar.?`, where `?` is a list of suffixes (such as `so` or `dll`)
derived from the initial value of `package.cpath`.  If still no files are
found, Nvim falls back to Lua's default search mechanism.  The first script
found is run and `require()` returns the value returned by the script if any,
else `true`.

The return value is cached after the first call to `require()` for each
module, with subsequent calls returning the cached value without searching for
or executing any script.  For further details on `require()`, see the Lua
documentation at https://www.lua.org/manual/5.1/manual.html#pdf-require.

For example, if 'runtimepath' is `foo,bar` and `package.cpath` was
`./?.so;./?.dll` at startup, `require('mod')` searches these paths in order
and loads the first module found:
    foo/lua/mod.lua
    foo/lua/mod/init.lua
    bar/lua/mod.lua
    bar/lua/mod/init.lua
    foo/lua/mod.so
    foo/lua/mod.dll
    bar/lua/mod.so
    bar/lua/mod.dll

                                                        *lua-package-path*
Nvim automatically adjusts `package.path` and `package.cpath` according to
effective 'runtimepath' value.  Adjustment happens whenever 'runtimepath' is
changed.  `package.path` is adjusted by simply appending `/lua/?.lua` and
`/lua/?/init.lua` to each directory from 'runtimepath' (`/` is actually the
first character of `package.config`).

Similarly to `package.path`, modified directories from 'runtimepath' are also
added to `package.cpath`.  In this case, instead of appending `/lua/?.lua` and
`/lua/?/init.lua` to each runtimepath, all unique `?`-containing suffixes of
the existing `package.cpath` are used.  Example:

1. Given that
   - 'runtimepath' contains `/foo/bar,/xxx;yyy/baz,/abc`;
   - initial (defined at compile-time or derived from 
     `$LUA_CPATH`/`$LUA_INIT`) `package.cpath` contains 
     `./?.so;/def/ghi/a?d/j/g.elf;/def/?.so`.
2. It finds `?`-containing suffixes `/?.so`, `/a?d/j/g.elf` and `/?.so`, in 
   order: parts of the path starting from the first path component containing 
   question mark and preceding path separator.
3. The suffix of `/def/?.so`, namely `/?.so` is not unique, as it’s the same 
   as the suffix of the first path from `package.path` (i.e. `./?.so`).  Which 
   leaves `/?.so` and `/a?d/j/g.elf`, in this order.
4. 'runtimepath' has three paths: `/foo/bar`, `/xxx;yyy/baz` and `/abc`.  The 
   second one contains semicolon which is a paths separator so it is out, 
   leaving only `/foo/bar` and `/abc`, in order.
5. The cartesian product of paths from 4. and suffixes from 3. is taken, 
   giving four variants. In each variant `/lua` path segment is inserted 
   between path and suffix, leaving

   - `/foo/bar/lua/?.so`
   - `/foo/bar/lua/a?d/j/g.elf`
   - `/abc/lua/?.so`
   - `/abc/lua/a?d/j/g.elf`

6. New paths are prepended to the original `package.cpath`.

The result will look like this:

    `/foo/bar,/xxx;yyy/baz,/abc` ('runtimepath')
    × `./?.so;/def/ghi/a?d/j/g.elf;/def/?.so` (`package.cpath`)

    = `/foo/bar/lua/?.so;/foo/bar/lua/a?d/j/g.elf;/abc/lua/?.so;/abc/lua/a?d/j/g.elf;./?.so;/def/ghi/a?d/j/g.elf;/def/?.so`

Note:

- To track 'runtimepath' updates, paths added at previous update are
  remembered and removed at the next update, while all paths derived from the
  new 'runtimepath' are prepended as described above.  This allows removing
  paths when path is removed from 'runtimepath', adding paths when they are
  added and reordering `package.path`/`package.cpath` content if 'runtimepath'
  was reordered.

- Although adjustments happen automatically, Nvim does not track current
  values of `package.path` or `package.cpath`.  If you happen to delete some
  paths from there you can set 'runtimepath' to trigger an update: >
      let &runtimepath = &runtimepath

- Skipping paths from 'runtimepath' which contain semicolons applies both to
  `package.path` and `package.cpath`.  Given that there are some badly written
  plugins using shell which will not work with paths containing semicolons it
  is better to not have them in 'runtimepath' at all.

==============================================================================
Lua Syntax Information                                         *lua-syntax-help*

While Lua has a simple syntax, there are a few things to understand,
particularly when looking at the documentation above.

                                                      *lua-syntax-call-function*

Lua functions can be called in multiple ways. Consider the function: >

    local example_func = function(a, b)
        print("A is: ", a)
        print("B is: ", b)
    end


The first way to call a function is: >
    
    example_func(1, 2)
    -- ==== Result ====
    -- A is: 1
    -- B is: 2
<
    This way of calling a function is familiar to most scripting languages.
    In Lua, it's important to understand that any function arguments that are
    not supplied are automatically set to `nil`. For example: >

    example_func(1)
    -- ==== Result ====
    -- A is: 1
    -- B is: nil
<

    Additionally, if any extra parameters are passed, they are discarded
    completely.

In Lua, it is also possible (when only one argument is passed) to call the
function without any parentheses. This is most often used to approximate
"keyword"-style arguments with a single dictionary. For example: >

    local func_with_opts = function(opts)
        local will_do_foo = opts.foo
        local filename = opts.filename

        ...
    end

    func_with_opts { foo = true, filename = "hello.world" }
<

    In this style, each "parameter" is passed via keyword. It is still valid
    to call the function in this style: >

    func_with_opts({ foo = true, filename = "hello.world" })
<

    But often in the documentation, you will see the former rather than the
    latter style, due to its brevity (this is vim after all!).


------------------------------------------------------------------------------
LUA PLUGIN EXAMPLE                                      *lua-require-example*

The following example plugin adds a command `:MakeCharBlob` which transforms 
current buffer into a long `unsigned char` array.  Lua contains transformation 
function in a module `lua/charblob.lua` which is imported in 
`autoload/charblob.vim` (`require("charblob")`).  Example plugin is supposed 
to be put into any directory from 'runtimepath', e.g. `~/.config/nvim` (in 
this case `lua/charblob.lua` means `~/.config/nvim/lua/charblob.lua`).

autoload/charblob.vim: >

    function charblob#encode_buffer()
      call setline(1, luaeval(
      \    'require("charblob").encode(unpack(_A))',
      \    [getline(1, '$'), &textwidth, '  ']))
    endfunction

plugin/charblob.vim: >

    if exists('g:charblob_loaded')
      finish
    endif
    let g:charblob_loaded = 1

    command MakeCharBlob :call charblob#encode_buffer()

lua/charblob.lua: >

    local function charblob_bytes_iter(lines)
      local init_s = {
        next_line_idx = 1,
        next_byte_idx = 1,
        lines = lines,
      }
      local function next(s, _)
        if lines[s.next_line_idx] == nil then
          return nil
        end
        if s.next_byte_idx > #(lines[s.next_line_idx]) then
          s.next_line_idx = s.next_line_idx + 1
          s.next_byte_idx = 1
          return ('\n'):byte()
        end
        local ret = lines[s.next_line_idx]:byte(s.next_byte_idx)
        if ret == ('\n'):byte() then
          ret = 0  -- See :h NL-used-for-NUL.
        end
        s.next_byte_idx = s.next_byte_idx + 1
        return ret
      end
      return next, init_s, nil
    end

    local function charblob_encode(lines, textwidth, indent)
      local ret = {
        'const unsigned char blob[] = {',
        indent,
      }
      for byte in charblob_bytes_iter(lines) do
        --                .- space + number (width 3) + comma
        if #(ret[#ret]) + 5 > textwidth then
          ret[#ret + 1] = indent
        else
          ret[#ret] = ret[#ret] .. ' '
        end
        ret[#ret] = ret[#ret] .. (('%3u,'):format(byte))
      end
      ret[#ret + 1] = '};'
      return ret
    end

    return {
      bytes_iter = charblob_bytes_iter,
      encode = charblob_encode,
    }

==============================================================================
COMMANDS                                                *lua-commands*

These commands execute a Lua chunk from either the command line (:lua, :luado)
or a file (:luafile) on the given line [range]. As always in Lua, each chunk
has its own scope (closure), so only global variables are shared between
command calls. The |lua-stdlib| modules, user modules, and anything else on
|lua-package-path| are available.

The Lua print() function redirects its output to the Nvim message area, with
arguments separated by " " (space) instead of "\t" (tab).

                                                        *:lua*
:[range]lua {chunk}
                        Executes Lua chunk {chunk}.
                        if {chunk} starts with "=" the rest of the chunk is
                        evaluated as an expression and printed. `:lua =expr`
                        is equivalent to `:lua print(vim.inspect(expr))`
                        Examples: >
                            :lua vim.api.nvim_command('echo "Hello, Nvim!"')
<                        To see the Lua version: >
                            :lua print(_VERSION)
<                        To see the LuaJIT version: >
                            :lua =jit.version
<
                                                        *:lua-heredoc*
:[range]lua << [endmarker]
{script}
{endmarker}
                        Executes Lua script {script} from within Vimscript.
                        {endmarker} must NOT be preceded by whitespace. You
                        can omit [endmarker] after the "<<" and use a dot "."
                        after {script} (similar to |:append|, |:insert|).

                        Example:
                        >
                            function! CurrentLineInfo()
                            lua << EOF
                            local linenr = vim.api.nvim_win_get_cursor(0)[1]
                            local curline = vim.api.nvim_buf_get_lines(
                                    0, linenr - 1, linenr, false)[1]
                            print(string.format("Current line [%d] has %d bytes",
                                    linenr, #curline))
                            EOF
                            endfunction

<                        Note that the `local` variables will disappear when
                        the block finishes. But not globals.

                                                        *:luado*
:[range]luado {body}    Executes Lua chunk "function(line, linenr) {body} end"
                        for each buffer line in [range], where `line` is the
                        current line text (without <EOL>), and `linenr` is the
                        current line number. If the function returns a string
                        that becomes the text of the corresponding buffer
                        line. Default [range] is the whole file: "1,$".

                        Examples:
                        >
                            :luado return string.format("%s\t%d", line:reverse(), #line)

                            :lua require"lpeg"
                            :lua -- balanced parenthesis grammar:
                            :lua bp = lpeg.P{ "(" * ((1 - lpeg.S"()") + lpeg.V(1))^0 * ")" }
                            :luado if bp:match(line) then return "-->\t" .. line end
<

                                                        *:luafile*
:[range]luafile {file}
                        Execute Lua script in {file}.
                        The whole argument is used as the filename (like
                        |:edit|), spaces do not need to be escaped.
                        Alternatively you can |:source| Lua files.

                        Examples: >
                            :luafile script.lua
                            :luafile %
<

==============================================================================
luaeval()                                               *lua-eval* *luaeval()*

The (dual) equivalent of "vim.eval" for passing Lua values to Nvim is
"luaeval". "luaeval" takes an expression string and an optional argument used 
for _A inside expression and returns the result of the expression. It is 
semantically equivalent in Lua to:
>
    local chunkheader = "local _A = select(1, ...) return "
    function luaeval (expstr, arg)
        local chunk = assert(loadstring(chunkheader .. expstr, "luaeval"))
        return chunk(arg) -- return typval
    end

Lua nils, numbers, strings, tables and booleans are converted to their
respective Vimscript types. If a Lua string contains a NUL byte, it will be
converted to a |Blob|. Conversion of other Lua types is an error.

The magic global "_A" contains the second argument to luaeval().

Example: >
    :echo luaeval('_A[1] + _A[2]', [40, 2])
    42
    :echo luaeval('string.match(_A, "[a-z]+")', 'XYXfoo123')
    foo

Lua tables are used as both dictionaries and lists, so it is impossible to
determine whether empty table is meant to be empty list or empty dictionary.
Additionally Lua does not have integer numbers. To distinguish between these
cases there is the following agreement:

0. Empty table is empty list.
1. Table with N incrementally growing integral numbers, starting from 1 and 
   ending with N is considered to be a list.
2. Table with string keys, none of which contains NUL byte, is considered to 
   be a dictionary.
3. Table with string keys, at least one of which contains NUL byte, is also 
   considered to be a dictionary, but this time it is converted to 
   a |msgpack-special-map|.
                                                        *lua-special-tbl*
4. Table with `vim.type_idx` key may be a dictionary, a list or floating-point 
   value:
   - `{[vim.type_idx]=vim.types.float, [vim.val_idx]=1}` is converted to
     a floating-point 1.0. Note that by default integral Lua numbers are
     converted to |Number|s, non-integral are converted to |Float|s. This
     variant allows integral |Float|s.
   - `{[vim.type_idx]=vim.types.dictionary}` is converted to an empty
     dictionary, `{[vim.type_idx]=vim.types.dictionary, [42]=1, a=2}` is
     converted to a dictionary `{'a': 42}`: non-string keys are ignored.
     Without `vim.type_idx` key tables with keys not fitting in 1., 2. or 3.
     are errors.
   - `{[vim.type_idx]=vim.types.array}` is converted to an empty list. As well
     as `{[vim.type_idx]=vim.types.array, [42]=1}`: integral keys that do not
     form a 1-step sequence from 1 to N are ignored, as well as all
     non-integral keys.

Examples: >

    :echo luaeval('math.pi')
    :function Rand(x,y) " random uniform between x and y
    :  return luaeval('(_A.y-_A.x)*math.random()+_A.x', {'x':a:x,'y':a:y})
    :  endfunction
    :echo Rand(1,10)

Note: second argument to `luaeval` is converted ("marshalled") from Vimscript
to Lua, so changes to Lua containers do not affect values in Vimscript. Return
value is also always converted. When converting, |msgpack-special-dict|s are
treated specially.

==============================================================================
Vimscript v:lua interface                               *v:lua-call*

From Vimscript the special `v:lua` prefix can be used to call Lua functions
which are global or accessible from global tables. The expression >
    v:lua.func(arg1, arg2)
is equivalent to the Lua chunk >
    return func(...)
where the args are converted to Lua values. The expression >
    v:lua.somemod.func(args)
is equivalent to the Lua chunk >
    return somemod.func(...)

In addition, functions of packages can be accessed like >
    v:lua.require'mypack'.func(arg1, arg2)
    v:lua.require'mypack.submod'.func(arg1, arg2)
Note: only single quote form without parens is allowed. Using
`require"mypack"` or `require('mypack')` as prefixes do NOT work (the latter
is still valid as a function call of itself, in case require returns a useful
value).

The `v:lua` prefix may be used to call Lua functions as |method|s. For
example: >
    arg1->v:lua.somemod.func(arg2)

You can use `v:lua` in "func" options like 'tagfunc', 'omnifunc', etc.
For example consider the following Lua omnifunc handler: >

    function mymod.omnifunc(findstart, base)
      if findstart == 1 then
        return 0
      else
        return {'stuff', 'steam', 'strange things'}
      end
    end
    vim.api.nvim_buf_set_option(0, 'omnifunc', 'v:lua.mymod.omnifunc')

Note: the module ("mymod" in the above example) must either be a Lua global,
or use the require syntax as specified above to access it from a package.

Note: `v:lua` without a call is not allowed in a Vimscript expression:
|Funcref|s cannot represent Lua functions. The following are errors: >

    let g:Myvar = v:lua.myfunc        " Error
    call SomeFunc(v:lua.mycallback)   " Error
    let g:foo = v:lua                 " Error
    let g:foo = v:['lua']             " Error


==============================================================================
Lua standard modules                                    *lua-stdlib*

The Nvim Lua "standard library" (stdlib) is the `vim` module, which exposes
various functions and sub-modules.  It is always loaded, thus require("vim")
is unnecessary.

You can peek at the module properties: >

    :lua print(vim.inspect(vim))

Result is something like this: >

    {
      _os_proc_children = <function 1>,
      _os_proc_info = <function 2>,
      ...
      api = {
        nvim__id = <function 5>,
        nvim__id_array = <function 6>,
        ...
      },
      deepcopy = <function 106>,
      gsplit = <function 107>,
      ...
    }

To find documentation on e.g. the "deepcopy" function: >

    :help vim.deepcopy()

Note that underscore-prefixed functions (e.g. "_os_proc_children") are
internal/private and must not be used by plugins.

------------------------------------------------------------------------------
VIM.LOOP                                                *lua-loop* *vim.loop*

`vim.loop` exposes all features of the Nvim event-loop.  This is a low-level
API that provides functionality for networking, filesystem, and process
management.  Try this command to see available functions: >

    :lua print(vim.inspect(vim.loop))

Reference: https://github.com/luvit/luv/blob/master/docs.md
Examples:  https://github.com/luvit/luv/tree/master/examples

                                                *E5560* *lua-loop-callbacks*
It is an error to directly invoke `vim.api` functions (except |api-fast|) in
`vim.loop` callbacks.  For example, this is an error: >

    local timer = vim.loop.new_timer()
    timer:start(1000, 0, function()
      vim.api.nvim_command('echomsg "test"')
    end)

To avoid the error use |vim.schedule_wrap()| to defer the callback: >

    local timer = vim.loop.new_timer()
    timer:start(1000, 0, vim.schedule_wrap(function()
      vim.api.nvim_command('echomsg "test"')
    end))

(For one-shot timers, see |vim.defer_fn()|, which automatically adds the wrapping.)

Example: repeating timer
    1. Save this code to a file.
    2. Execute it with ":luafile %". >

    -- Create a timer handle (implementation detail: uv_timer_t).
    local timer = vim.loop.new_timer()
    local i = 0
    -- Waits 1000ms, then repeats every 750ms until timer:close().
    timer:start(1000, 750, function()
      print('timer invoked! i='..tostring(i))
      if i > 4 then
        timer:close()  -- Always close handles to avoid leaks.
      end
      i = i + 1
    end)
    print('sleeping');


Example: File-change detection                          *watch-file*
    1. Save this code to a file.
    2. Execute it with ":luafile %".
    3. Use ":Watch %" to watch any file.
    4. Try editing the file from another text editor.
    5. Observe that the file reloads in Nvim (because on_change() calls
       |:checktime|). >

    local w = vim.loop.new_fs_event()
    local function on_change(err, fname, status)
      -- Do work...
      vim.api.nvim_command('checktime')
      -- Debounce: stop/start.
      w:stop()
      watch_file(fname)
    end
    function watch_file(fname)
      local fullpath = vim.api.nvim_call_function(
        'fnamemodify', {fname, ':p'})
      w:start(fullpath, {}, vim.schedule_wrap(function(...)
        on_change(...) end))
    end
    vim.api.nvim_command(
      "command! -nargs=1 Watch call luaeval('watch_file(_A)', expand('<args>'))")


Example: TCP echo-server                                *tcp-server*
    1. Save this code to a file.
    2. Execute it with ":luafile %".
    3. Note the port number.
    4. Connect from any TCP client (e.g. "nc 0.0.0.0 36795"): >

    local function create_server(host, port, on_connect)
      local server = vim.loop.new_tcp()
      server:bind(host, port)
      server:listen(128, function(err)
        assert(not err, err)  -- Check for errors.
        local sock = vim.loop.new_tcp()
        server:accept(sock)  -- Accept client connection.
        on_connect(sock)  -- Start reading messages.
      end)
      return server
    end
    local server = create_server('0.0.0.0', 0, function(sock)
      sock:read_start(function(err, chunk)
        assert(not err, err)  -- Check for errors.
        if chunk then
          sock:write(chunk)  -- Echo received messages to the channel.
        else  -- EOF (stream closed).
          sock:close()  -- Always close handles to avoid leaks.
        end
      end)
    end)
    print('TCP echo-server listening on port: '..server:getsockname().port)


Multithreading						*lua-loop-threading*

Plugins can perform work in separate (os-level) threads using the threading
APIs in luv, for instance `vim.loop.new_thread`. Note that every thread
gets its own separate lua interpreter state, with no access to lua globals
in the main thread. Neither can the state of the editor (buffers, windows,
etc) be directly accessed from threads.

A subset of the `vim.*` API is available in threads. This includes:

- `vim.loop` with a separate event loop per thread.
- `vim.mpack` and `vim.json` (useful for serializing messages between threads)
- `require` in threads can use lua packages from the global |lua-package-path|
- `print()` and `vim.inspect`
- `vim.diff`
- most utility functions in `vim.*` for working with pure lua values
  like `vim.split`, `vim.tbl_*`, `vim.list_*`, and so on.
- `vim.is_thread()` returns true from a non-main thread.

------------------------------------------------------------------------------
VIM.HIGHLIGHT                                           *lua-highlight*

Nvim includes a function for highlighting a selection on yank (see for example
https://github.com/machakann/vim-highlightedyank). To enable it, add
>
 au TextYankPost * silent! lua vim.highlight.on_yank()
<
to your `init.vim`. You can customize the highlight group and the duration of
the highlight via
>
 au TextYankPost * silent! lua vim.highlight.on_yank {higroup="IncSearch", timeout=150}
<
If you want to exclude visual selections from highlighting on yank, use
>
 au TextYankPost * silent! lua vim.highlight.on_yank {on_visual=false}
<

vim.highlight.on_yank({opts})                         *vim.highlight.on_yank()*
        Highlights the yanked text. The fields of the optional dict {opts}
        control the highlight:
          - {higroup} highlight group for yanked region (default |hl-IncSearch|)
          - {timeout} time in ms before highlight is cleared (default `150`)
          - {on_macro} highlight when executing macro (default `false`)
          - {on_visual} highlight when yanking visual selection (default `true`)
          - {event} event structure (default |v:event|)

vim.highlight.range({bufnr}, {ns}, {hlgroup}, {start}, {finish}, {opts})
                                                       *vim.highlight.range()*

        Apply highlight group to range of text.

                Parameters: ~
                    {bufnr}   buffer number
                    {ns}      namespace for highlights
                    {hlgroup} highlight group name
                    {start}   starting position (tuple {line,col})
                    {finish}  finish position (tuple {line,col})
                    {opts}    optional parameters:
                              • `regtype`: type of range (characterwise, linewise,
                                or blockwise, see |setreg|), default `'v'`
                              • `inclusive`: range includes end position, default
                                `false`
                              • `priority`: priority of highlight, default
                                `vim.highlight.user` (see below)

vim.highlight.priorities                           *vim.highlight.priorities*

        Table with default priorities used for highlighting:
            • `syntax`: `50`, used for standard syntax highlighting
            • `treesitter`: `100`, used for tree-sitter-based highlighting
            • `diagnostics`: `150`, used for code analysis such as diagnostics
            • `user`: `200`, used for user-triggered highlights such as LSP
              document symbols or `on_yank` autocommands

------------------------------------------------------------------------------
VIM.REGEX                                                       *lua-regex*

Vim regexes can be used directly from lua. Currently they only allow
matching within a single line.

vim.regex({re})                                         *vim.regex()*
        Parse the Vim regex {re} and return a regex object. Regexes are
        "magic" and case-insensitive by default, regardless of 'magic' and
        'ignorecase'.  The can be controlled with flags, see |/magic|.

Methods on the regex object:

regex:match_str({str})                                  *regex:match_str()*
        Match the string against the regex. If the string should match the
        regex precisely, surround the regex with `^` and `$`.
        If the was a match, the byte indices for the beginning and end of
        the match is returned. When there is no match, `nil` is returned.
        As any integer is truth-y, `regex:match()` can be directly used
        as a condition in an if-statement.

regex:match_line({bufnr}, {line_idx}[, {start}, {end}]) *regex:match_line()*
        Match line {line_idx} (zero-based) in buffer {bufnr}. If {start} and
        {end} are supplied, match only this byte index range. Otherwise see
        |regex:match_str()|. If {start} is used, then the returned byte
        indices will be relative {start}.

------------------------------------------------------------------------------
VIM.DIFF                                                            *lua-diff*

vim.diff({a}, {b}, {opts})                                        *vim.diff()*
                Run diff on strings {a} and {b}. Any indices returned by this
                function, either directly or via callback arguments, are
                1-based.

                Examples: >
                vim.diff('a\n', 'b\nc\n')
                -->
                @@ -1 +1,2 @@
                -a
                +b
                +c

                vim.diff('a\n', 'b\nc\n', {result_type = 'indices'})
                -->
                {
                    {1, 1, 1, 2}
                }
<
                Parameters: ~
                    {a}      First string to compare
                    {b}      Second string to compare
                    {opts}   Optional parameters:
                             • `on_hunk` (callback):
                               Invoked for each hunk in the diff. Return a
                               negative number to cancel the callback for any
                               remaining hunks.
                               Args:
                               • `start_a` (integer): Start line of hunk in {a}.
                               • `count_a` (integer): Hunk size in {a}.
                               • `start_b` (integer): Start line of hunk in {b}.
                               • `count_b` (integer): Hunk size in {b}.
                             • `result_type` (string): Form of the returned diff:
                               • "unified": (default) String in unified format.
                               • "indices": Array of hunk locations.
                               Note this option is ignored if `on_hunk` is
                               used.
                             • `algorithm` (string):
                               Diff algorithm to use. Values:
                               • "myers"      the default algorithm
                               • "minimal"    spend extra time to generate the
                                              smallest possible diff
                               • "patience"   patience diff algorithm
                               • "histogram"  histogram diff algorithm
                             • `ctxlen` (integer): Context length
                             • `interhunkctxlen` (integer):
                               Inter hunk context length
                             • `ignore_whitespace` (boolean):
                               Ignore whitespace
                             • `ignore_whitespace_change` (boolean):
                               Ignore whitespace change
                             • `ignore_whitespace_change_at_eol` (boolean)
                               Ignore whitespace change at end-of-line.
                             • `ignore_cr_at_eol` (boolean)
                               Ignore carriage return at end-of-line
                             • `ignore_blank_lines` (boolean)
                               Ignore blank lines
                             • `indent_heuristic` (boolean):
                               Use the indent heuristic for the internal
                               diff library.

                Return: ~
                    See {opts.result_type}. nil if {opts.on_hunk} is given.

------------------------------------------------------------------------------
VIM.MPACK                                                          *lua-mpack*

The *vim.mpack* module provides encoding and decoding of Lua objects to and
from msgpack-encoded strings. Supports |vim.NIL| and |vim.empty_dict()|.

vim.mpack.encode({obj})                                 *vim.mpack.encode*
        Encodes (or "packs") Lua object {obj} as msgpack in a Lua string.

vim.mpack.decode({str})                                 *vim.mpack.decode*
        Decodes (or "unpacks") the msgpack-encoded {str} to a Lua object.

------------------------------------------------------------------------------
VIM.SPELL                                                           *lua-spell*

vim.spell.check({str})                                      *vim.spell.check()*
        Check {str} for spelling errors. Similar to the Vimscript function
        |spellbadword()|.

        Note: The behaviour of this function is dependent on: 'spelllang',
        'spellfile', 'spellcapcheck' and 'spelloptions' which can all be local
        to the buffer. Consider calling this with |nvim_buf_call()|.

        Example: >
            vim.spell.check("the quik brown fox")
            -->
            {
                {'quik', 'bad', 4}
            }
<

        Parameters: ~
            {str}    String to spell check.

        Return: ~
          List of tuples with three items:
            - The badly spelled word.
            - The type of the spelling error:
                "bad"   spelling mistake
                "rare"  rare word
                "local" word only valid in another region
                "caps"  word should start with Capital
            - The position in {str} where the word begins.

------------------------------------------------------------------------------
VIM                                                     *lua-builtin*

vim.api.{func}({...})                                   *vim.api*
        Invokes Nvim |API| function {func} with arguments {...}.
        Example: call the "nvim_get_current_line()" API function: >
            print(tostring(vim.api.nvim_get_current_line()))

vim.version()                                           *vim.version*
        Gets the version of the current Nvim build.

vim.in_fast_event()                                     *vim.in_fast_event()*
        Returns true if the code is executing as part of a "fast" event
        handler, where most of the API is disabled. These are low-level events
        (e.g. |lua-loop-callbacks|) which can be invoked whenever Nvim polls
        for input.  When this is `false` most API functions are callable (but
        may be subject to other restrictions such as |textlock|).

vim.NIL                                                             *vim.NIL*
        Special value representing NIL in |RPC| and |v:null| in Vimscript
        conversion, and similar cases. Lua `nil` cannot be used as part of
        a Lua table representing a Dictionary or Array, because it is
        treated as missing: `{"foo", nil}` is the same as `{"foo"}`.

vim.empty_dict()                                            *vim.empty_dict()*
        Creates a special empty table (marked with a metatable), which Nvim
        converts to an empty dictionary when translating Lua values to
        Vimscript or API types. Nvim by default converts an empty table `{}`
        without this metatable to an list/array.

        Note: if numeric keys are present in the table, Nvim ignores the
        metatable marker and converts the dict to a list/array anyway.

vim.rpcnotify({channel}, {method}[, {args}...])             *vim.rpcnotify()*
        Sends {event} to {channel} via |RPC| and returns immediately. If
        {channel} is 0, the event is broadcast to all channels.

        This function also works in a fast callback |lua-loop-callbacks|.

vim.rpcrequest({channel}, {method}[, {args}...])            *vim.rpcrequest()*
        Sends a request to {channel} to invoke {method} via |RPC| and blocks
        until a response is received.

        Note: NIL values as part of the return value is represented as
        |vim.NIL| special value

vim.stricmp({a}, {b})                                   *vim.stricmp()*
        Compares strings case-insensitively.  Returns 0, 1 or -1 if strings
        are equal, {a} is greater than {b} or {a} is lesser than {b},
        respectively.

vim.str_utfindex({str}[, {index}])                      *vim.str_utfindex()*
        Convert byte index to UTF-32 and UTF-16 indices. If {index} is not
        supplied, the length of the string is used. All indices are zero-based.
        Returns two values: the UTF-32 and UTF-16 indices respectively.

        Embedded NUL bytes are treated as terminating the string. Invalid
        UTF-8 bytes, and embedded surrogates are counted as one code
        point each. An {index} in the middle of a UTF-8 sequence is rounded
        upwards to the end of that sequence.

vim.str_byteindex({str}, {index}[, {use_utf16}])	*vim.str_byteindex()*
        Convert UTF-32 or UTF-16 {index} to byte index. If {use_utf16} is not
        supplied, it defaults to false (use UTF-32). Returns the byte index.

        Invalid UTF-8 and NUL is treated like by |vim.str_byteindex()|. An {index}
        in the middle of a UTF-16 sequence is rounded upwards to the end of that
        sequence.

vim.schedule({callback})				*vim.schedule()*
        Schedules {callback} to be invoked soon by the main event-loop. Useful
        to avoid |textlock| or other temporary restrictions.


vim.defer_fn({fn}, {timeout})                                    *vim.defer_fn*
    Defers calling {fn} until {timeout} ms passes.  Use to do a one-shot timer
    that calls {fn}.

    Note: The {fn} is |schedule_wrap|ped automatically, so API functions are
    safe to call.

    Parameters: ~
        {fn}        Callback to call once {timeout} expires
        {timeout}   Time in ms to wait before calling {fn}

    Returns: ~
        |vim.loop|.new_timer() object

vim.wait({time} [, {callback}, {interval}, {fast_only}])          *vim.wait()*
        Wait for {time} in milliseconds until {callback} returns `true`.

        Executes {callback} immediately and at approximately {interval}
        milliseconds (default 200). Nvim still processes other events during
        this time.

    Parameters: ~
        {time}      Number of milliseconds to wait
        {callback}  Optional callback. Waits until {callback} returns true
        {interval}  (Approximate) number of milliseconds to wait between polls
        {fast_only} If true, only |api-fast| events will be processed.
                        If called from while in an |api-fast| event, will
                        automatically be set to `true`.

    Returns: ~
        If {callback} returns `true` during the {time}:
            `true, nil`

        If {callback} never returns `true` during the {time}:
            `false, -1`

        If {callback} is interrupted during the {time}:
            `false, -2`

        If {callback} errors, the error is raised.

        Examples: >

    ---
    -- Wait for 100 ms, allowing other events to process
    vim.wait(100, function() end)

    ---
    -- Wait for 100 ms or until global variable set.
    vim.wait(100, function() return vim.g.waiting_for_var end)

    ---
    -- Wait for 1 second or until global variable set, checking every ~500 ms
    vim.wait(1000, function() return vim.g.waiting_for_var end, 500)

    ---
    -- Schedule a function to set a value in 100ms
    vim.defer_fn(function() vim.g.timer_result = true end, 100)

    -- Would wait ten seconds if results blocked. Actually only waits  100 ms
    if vim.wait(10000, function() return vim.g.timer_result end) then
      print('Only waiting a little bit of time!')
    end
<

vim.type_idx                                            *vim.type_idx*
        Type index for use in |lua-special-tbl|.  Specifying one of the values
        from |vim.types| allows typing the empty table (it is unclear whether
        empty Lua table represents empty list or empty array) and forcing
        integral numbers to be |Float|.  See |lua-special-tbl| for more
        details.

vim.val_idx                                             *vim.val_idx*
        Value index for tables representing |Float|s.  A table representing
        floating-point value 1.0 looks like this: >
            {
              [vim.type_idx] = vim.types.float,
              [vim.val_idx] = 1.0,
            }
<       See also |vim.type_idx| and |lua-special-tbl|.

vim.types                                               *vim.types*
        Table with possible values for |vim.type_idx|.  Contains two sets of
        key-value pairs: first maps possible values for |vim.type_idx| to
        human-readable strings, second maps human-readable type names to
        values for |vim.type_idx|.  Currently contains pairs for `float`,
        `array` and `dictionary` types.

        Note: one must expect that values corresponding to `vim.types.float`,
        `vim.types.array` and `vim.types.dictionary` fall under only two
        following assumptions:
        1. Value may serve both as a key and as a value in a table.  Given the
           properties of Lua tables this basically means “value is not `nil`”.
        2. For each value in `vim.types` table `vim.types[vim.types[value]]`
           is the same as `value`.
        No other restrictions are put on types, and it is not guaranteed that
        values corresponding to `vim.types.float`, `vim.types.array` and
        `vim.types.dictionary` will not change or that `vim.types` table will
        only contain values for these three types.

                                                   *log_levels* *vim.log.levels*
Log levels are one of the values defined in `vim.log.levels`:

        vim.log.levels.DEBUG
        vim.log.levels.ERROR
        vim.log.levels.INFO
        vim.log.levels.TRACE
        vim.log.levels.WARN

------------------------------------------------------------------------------
LUA-VIMSCRIPT BRIDGE                                    *lua-vimscript*

Nvim Lua provides an interface to Vimscript variables and functions, and
editor commands and options.
See also https://github.com/nanotee/nvim-lua-guide.

vim.call({func}, {...})					*vim.call()*
        Invokes |vim-function| or |user-function| {func} with arguments {...}.
        See also |vim.fn|.
        Equivalent to: >
            vim.fn[func]({...})

vim.cmd({cmd})                                          *vim.cmd()*
        Executes multiple lines of Vimscript at once. It is an alias to
        |nvim_exec()|, where `output` is set to false. Thus it works identical
        to |:source|.
        See also |ex-cmd-index|.
        Example: >
            vim.cmd('echo 42')
            vim.cmd([[
              augroup My_group
                autocmd!
                autocmd FileType c setlocal cindent
              augroup END
            ]])

vim.fn.{func}({...})					*vim.fn*
        Invokes |vim-function| or |user-function| {func} with arguments {...}.
        To call autoload functions, use the syntax: >
            vim.fn['some#function']({...})
<
        Unlike vim.api.|nvim_call_function()| this converts directly between Vim
        objects and Lua objects. If the Vim function returns a float, it will
        be represented directly as a Lua number. Empty lists and dictionaries
        both are represented by an empty table.

        Note: |v:null| values as part of the return value is represented as
        |vim.NIL| special value

        Note: vim.fn keys are generated lazily, thus `pairs(vim.fn)` only
        enumerates functions that were called at least once.


                                                        *lua-vim-variables*
The Vim editor global dictionaries |g:| |w:| |b:| |t:| |v:| can be accessed
from Lua conveniently and idiomatically by referencing the `vim.*` Lua tables
described below. In this way you can easily read and modify global Vimscript
variables from Lua.

Example: >

    vim.g.foo = 5     -- Set the g:foo Vimscript variable.
    print(vim.g.foo)  -- Get and print the g:foo Vimscript variable.
    vim.g.foo = nil   -- Delete (:unlet) the Vimscript variable.
    vim.b[2].foo = 6  -- Set b:foo for buffer 2

vim.g                                                   *vim.g*
        Global (|g:|) editor variables.
        Key with no value returns `nil`.

vim.b                                                   *vim.b*
        Buffer-scoped (|b:|) variables for the current buffer.
        Invalid or unset key returns `nil`. Can be indexed with
        an integer to access variables for a specific buffer.

vim.w                                                   *vim.w*
        Window-scoped (|w:|) variables for the current window.
        Invalid or unset key returns `nil`. Can be indexed with
        an integer to access variables for a specific window.

vim.t                                                   *vim.t*
        Tabpage-scoped (|t:|) variables for the current tabpage.
        Invalid or unset key returns `nil`. Can be indexed with
        an integer to access variables for a specific tabpage.

vim.v                                                   *vim.v*
        |v:| variables.
        Invalid or unset key returns `nil`.

vim.env                                                 *vim.env*
        Environment variables defined in the editor session.
        See |expand-env| and |:let-environment| for the Vimscript behavior.
        Invalid or unset key returns `nil`.
        Example: >
            vim.env.FOO = 'bar'
            print(vim.env.TERM)
<

                                                             *lua-vim-options*
                                                                 *lua-vim-opt*
                                                                 *lua-vim-set*
                                                            *lua-vim-optlocal*
                                                            *lua-vim-setlocal*

In Vimscript, there is an way to set options |set-option|. In Lua, the
corresponding method is `vim.opt`.

`vim.opt` provides several conveniences for setting and controlling options
from within Lua.

    Examples: ~

    To set a boolean toggle:
        In Vimscript:
            `set number`

        In Lua:
            `vim.opt.number = true`

    To set an array of values:
        In Vimscript:
            `set wildignore=*.o,*.a,__pycache__`

        In Lua, there are two ways you can do this now. One is very similar to
        the Vimscript form:
            `vim.opt.wildignore = '*.o,*.a,__pycache__'`

        However, vim.opt also supports a more elegent way of setting
        list-style options by using lua tables:
            `vim.opt.wildignore = { '*.o', '*.a', '__pycache__' }`

    To replicate the behavior of |:set+=|, use: >

        -- vim.opt supports appending options via the "+" operator
        vim.opt.wildignore = vim.opt.wildignore + { "*.pyc", "node_modules" }

        -- or using the `:append(...)` method
        vim.opt.wildignore:append { "*.pyc", "node_modules" }
<

    To replicate the behavior of |:set^=|, use: >

        -- vim.opt supports prepending options via the "^" operator
        vim.opt.wildignore = vim.opt.wildignore ^ { "new_first_value" }

        -- or using the `:prepend(...)` method
        vim.opt.wildignore:prepend { "new_first_value" }
<
    To replicate the behavior of |:set-=|, use: >

        -- vim.opt supports removing options via the "-" operator
        vim.opt.wildignore = vim.opt.wildignore - { "node_modules" }

        -- or using the `:remove(...)` method
        vim.opt.wildignore:remove { "node_modules" }
<
    To set a map of values:
        In Vimscript:
            `set listchars=space:_,tab:>~`

        In Lua:
            `vim.opt.listchars = { space = '_', tab = '>~' }`


In any of the above examples, to replicate the behavior |setlocal|, use
`vim.opt_local`. Additionally, to replicate the behavior of |setglobal|, use
`vim.opt_global`.
                                                                     *vim.opt*

|vim.opt| returns an Option object.

For example: `local listchar_object = vim.opt.listchars`

An `Option` has the following methods:


                                                               *vim.opt:get()*
Option:get()

    Returns a lua-representation of the option. Boolean, number and string
    values will be returned in exactly the same fashion.

    For values that are comma-separated lists, an array will be returned with
    the values as entries in the array: >
        vim.cmd [[set wildignore=*.pyc,*.o]]

        print(vim.inspect(vim.opt.wildignore:get()))
        -- { "*.pyc", "*.o", }

        for _, ignore_pattern in ipairs(vim.opt.wildignore:get()) do
            print("Will ignore:", ignore_pattern)
        end
        -- Will ignore: *.pyc
        -- Will ignore: *.o
<
    For values that are comma-separated maps, a table will be returned with
    the names as keys and the values as entries: >
        vim.cmd [[set listchars=space:_,tab:>~]]

        print(vim.inspect(vim.opt.listchars:get()))
        --  { space = "_", tab = ">~", }

        for char, representation in pairs(vim.opt.listchars:get()) do
            print(char, "->", representation)
        end
<
    For values that are lists of flags, a set will be returned with the flags
    as keys and `true` as entries. >
        vim.cmd [[set formatoptions=njtcroql]]

        print(vim.inspect(vim.opt.formatoptions:get()))
        -- { n = true, j = true, c = true, ... }

        local format_opts = vim.opt.formatoptions:get()
        if format_opts.j then
            print("J is enabled!")
        end
<
                                                            *vim.opt:append()*
Option:append(value)

    Append a value to string-style options. See |:set+=|

    These are equivalent:
        `vim.opt.formatoptions:append('j')`
        `vim.opt.formatoptions = vim.opt.formatoptions + 'j'`

                                                           *vim.opt:prepend()*
Option:prepend(value)

    Prepend a value to string-style options. See |:set^=|

    These are equivalent:
        `vim.opt.wildignore:prepend('*.o')`
        `vim.opt.wildignore = vim.opt.wildignore ^ '*.o'`

                                                            *vim.opt:remove()*
Option:remove(value)

    Remove a value from string-style options. See |:set-=|

    These are equivalent:
        `vim.opt.wildignore:remove('*.pyc')`
        `vim.opt.wildignore = vim.opt.wildignore - '*.pyc'`


In general, using `vim.opt` will provide the expected result when the user is
used to interacting with editor |options| via `set`. There are still times
where the user may want to set particular options via a shorthand in Lua,
which is where |vim.o|, |vim.bo|, |vim.wo|, and |vim.go| come into play.

The behavior of |vim.o|, |vim.bo|, |vim.wo|, and |vim.go| is designed to
follow that of |:set|, |:setlocal|, and |:setglobal| which can be seen in the
table below:

    lua            command      global_value       local_value ~
vim.o           :set                set                set
vim.bo/vim.wo   :setlocal            -                 set
vim.go          :setglobal          set                 -

vim.o                                                   *vim.o*
        Get or set editor options, like |:set|. Invalid key is an error.
        Example: >
            vim.o.cmdheight = 4
            print(vim.o.columns)


vim.go                                                  *vim.go*
        Get or set an |option|. Invalid key is an error.

        This is a wrapper around |nvim_set_option()| and |nvim_get_option()|.

        NOTE: This is different than |vim.o| because this ONLY sets the global
        option, which generally produces confusing behavior for options with
        |global-local| values.

        Example: >
            vim.go.cmdheight = 4
<

vim.bo                                                  *vim.bo*
        Get or set buffer-scoped |local-options|. Invalid key is an error.

        This is a wrapper around |nvim_buf_set_option()| and
        |nvim_buf_get_option()|.

        Example: >
            vim.bo.buflisted = true
            print(vim.bo.comments)

vim.wo                                                  *vim.wo*
        Get or set window-scoped |local-options|. Invalid key is an error.

        This is a wrapper around |nvim_win_set_option()| and
        |nvim_win_get_option()|.

        Example: >
            vim.wo.cursorcolumn = true
            print(vim.wo.foldmarker)


==============================================================================
Lua module: vim                                                      *lua-vim*

                                             *vim.connection_failure_errmsg()*
connection_failure_errmsg({consequence})
                TODO: Documentation

defer_fn({fn}, {timeout})                                     *vim.defer_fn()*
                Defers calling `fn` until `timeout` ms passes.

                Use to do a one-shot timer that calls `fn` Note: The {fn} is |schedule_wrap|ped automatically, so API
                functions are safe to call.

                Parameters: ~
                    {fn}       Callback to call once `timeout` expires
                    {timeout}  Number of milliseconds to wait before calling
                               `fn`

                Return: ~
                    timer luv timer object

inspect({object}, {options})                                   *vim.inspect()*
                Return a human-readable representation of the given object.

                See also: ~
                    https://github.com/kikito/inspect.lua
                    https://github.com/mpeterv/vinspect

notify({msg}, {level}, {opts})                                  *vim.notify()*
                Display a notification to the user.

                This function can be overridden by plugins to display
                notifications using a custom provider (such as the system
                notification provider). By default, writes to |:messages|.

                Parameters: ~
                    {msg}    string Content of the notification to show to the
                             user.
                    {level}  number|nil One of the values from
                             |vim.log.levels|.
                    {opts}   table|nil Optional parameters. Unused by default.

notify_once({msg}, {level}, {opts})                        *vim.notify_once()*
                Display a notification only one time.

                Like |vim.notify()|, but subsequent calls with the same
                message will not display a notification.

                Parameters: ~
                    {msg}    string Content of the notification to show to the
                             user.
                    {level}  number|nil One of the values from
                             |vim.log.levels|.
                    {opts}   table|nil Optional parameters. Unused by default.

on_key({fn}, {ns_id})                                           *vim.on_key()*
                Adds Lua function {fn} with namespace id {ns_id} as a listener
                to every, yes every, input key.

                The Nvim command-line option |-w| is related but does not
                support callbacks and cannot be toggled dynamically.

                Note:
                    {fn} will not be cleared by |nvim_buf_clear_namespace()|

                Note:
                    {fn} will receive the keys after mappings have been
                    evaluated

                Parameters: ~
                    {fn}     function: Callback function. It should take one
                             string argument. On each key press, Nvim passes
                             the key char to fn(). |i_CTRL-V| If {fn} is nil,
                             it removes the callback for the associated
                             {ns_id}
                    {ns_id}  number? Namespace ID. If nil or 0, generates and
                             returns a new |nvim_create_namespace()| id.

                Return: ~
                    number Namespace id associated with {fn}. Or count of all
                    callbacks if on_key() is called without arguments.

                Note:
                    {fn} will be removed if an error occurs while calling.

paste({lines}, {phase})                                          *vim.paste()*
                Paste handler, invoked by |nvim_paste()| when a conforming UI
                (such as the |TUI|) pastes text into the editor.

                Example: To remove ANSI color codes when pasting: >

                 vim.paste = (function(overridden)
                   return function(lines, phase)
                     for i,line in ipairs(lines) do
                       -- Scrub ANSI color codes from paste input.
                       lines[i] = line:gsub('\27%[[0-9;mK]+', '')
                     end
                     overridden(lines, phase)
                   end
                 end)(vim.paste)
<

                Parameters: ~
                    {lines}  |readfile()|-style list of lines to paste.
                             |channel-lines|
                    {phase}  -1: "non-streaming" paste: the call contains all
                             lines. If paste is "streamed", `phase` indicates the stream state:
                             • 1: starts the paste (exactly once)
                             • 2: continues the paste (zero or more times)
                             • 3: ends the paste (exactly once)

                Return: ~
                    false if client should cancel the paste.

                See also: ~
                    |paste|

pretty_print({...})                                       *vim.pretty_print()*
                Prints given arguments in human-readable format. Example: >
                  -- Print highlight group Normal and store it's contents in a variable.
                  local hl_normal = vim.pretty_print(vim.api.nvim_get_hl_by_name("Normal", true))
<

                Return: ~
                    given arguments.

                See also: ~
                    |vim.inspect()|

region({bufnr}, {pos1}, {pos2}, {regtype}, {inclusive})         *vim.region()*
                Get a table of lines with start, end columns for a region
                marked by two points

                Parameters: ~
                    {bufnr}      number of buffer
                    {pos1}       (line, column) tuple marking beginning of
                                 region
                    {pos2}       (line, column) tuple marking end of region
                    {regtype}    type of selection (:help setreg)
                    {inclusive}  boolean indicating whether the selection is
                                 end-inclusive

                Return: ~
                    region lua table of the form {linenr = {startcol,endcol}}

schedule_wrap({cb})                                      *vim.schedule_wrap()*
                Defers callback `cb` until the Nvim API is safe to call.

                See also: ~
                    |lua-loop-callbacks|
                    |vim.schedule()|
                    |vim.in_fast_event()|




deep_equal({a}, {b})                                        *vim.deep_equal()*
                Deep compare values for equality

                Tables are compared recursively unless they both provide the `eq` methamethod. All other types are compared using the equality `==` operator.

                Parameters: ~
                    {a}  first value
                    {b}  second value

                Return: ~
                    `true` if values are equals, else `false`.

deepcopy({orig})                                              *vim.deepcopy()*
                Returns a deep copy of the given object. Non-table objects are
                copied as in a typical Lua assignment, whereas table objects
                are copied recursively. Functions are naively copied, so
                functions in the copied table point to the same functions as
                those in the input table. Userdata and threads are not copied
                and will throw an error.

                Parameters: ~
                    {orig}  table Table to copy

                Return: ~
                    New table of copied keys and (nested) values.

endswith({s}, {suffix})                                       *vim.endswith()*
                Tests if `s` ends with `suffix`.

                Parameters: ~
                    {s}       (string) a string
                    {suffix}  (string) a suffix

                Return: ~
                    (boolean) true if `suffix` is a suffix of s

gsplit({s}, {sep}, {plain})                                     *vim.gsplit()*
                Splits a string at each instance of a separator.

                Parameters: ~
                    {s}      String to split
                    {sep}    Separator string or pattern
                    {plain}  If `true` use `sep` literally (passed to
                             String.find)

                Return: ~
                    Iterator over the split components

                See also: ~
                    |vim.split()|
                    https://www.lua.org/pil/20.2.html
                    http://lua-users.org/wiki/StringLibraryTutorial

is_callable({f})                                           *vim.is_callable()*
                Returns true if object `f` can be called as a function.

                Parameters: ~
                    {f}  Any object

                Return: ~
                    true if `f` is callable, else false

list_extend({dst}, {src}, {start}, {finish})               *vim.list_extend()*
                Extends a list-like table with the values of another list-like
                table.

                NOTE: This mutates dst!

                Parameters: ~
                    {dst}     list which will be modified and appended to.
                    {src}     list from which values will be inserted.
                    {start}   Start index on src. defaults to 1
                    {finish}  Final index on src. defaults to #src

                Return: ~
                    dst

                See also: ~
                    |vim.tbl_extend()|

list_slice({list}, {start}, {finish})                       *vim.list_slice()*
                Creates a copy of a table containing only elements from start
                to end (inclusive)

                Parameters: ~
                    {list}    table table
                    {start}   integer Start range of slice
                    {finish}  integer End range of slice

                Return: ~
                    Copy of table sliced from start to finish (inclusive)

pesc({s})                                                         *vim.pesc()*
                Escapes magic chars in a Lua pattern.

                Parameters: ~
                    {s}  String to escape

                Return: ~
                    %-escaped pattern string

                See also: ~
                    https://github.com/rxi/lume

split({s}, {sep}, {kwargs})                                      *vim.split()*
                Splits a string at each instance of a separator.

                Examples: >

                  split(":aa::b:", ":")     --> {'','aa','','b',''}
                  split("axaby", "ab?")     --> {'','x','y'}
                  split("x*yz*o", "*", {plain=true})  --> {'x','yz','o'}
                  split("|x|y|z|", "|", {trimempty=true}) --> {'x', 'y', 'z'}
<

                Parameters: ~
                    {s}       String to split
                    {sep}     Separator string or pattern
                    {kwargs}  Keyword arguments:
                              • plain: (boolean) If `true` use `sep` literally
                                (passed to string.find)
                              • trimempty: (boolean) If `true` remove empty
                                items from the front and back of the list

                Return: ~
                    List-like table of the split components.

                See also: ~
                    |vim.gsplit()|

startswith({s}, {prefix})                                   *vim.startswith()*
                Tests if `s` starts with `prefix`.

                Parameters: ~
                    {s}       (string) a string
                    {prefix}  (string) a prefix

                Return: ~
                    (boolean) true if `prefix` is a prefix of s

tbl_add_reverse_lookup({o})                     *vim.tbl_add_reverse_lookup()*
                Add the reverse lookup values to an existing table. For
                example: `tbl_add_reverse_lookup { A = 1 } == { [1] = 'A', A = 1 }`

                Parameters: ~
                    {o}  table The table to add the reverse to.

tbl_contains({t}, {value})                                *vim.tbl_contains()*
                Checks if a list-like (vector) table contains `value`.

                Parameters: ~
                    {t}      Table to check
                    {value}  Value to compare

                Return: ~
                    true if `t` contains `value`

tbl_count({t})                                               *vim.tbl_count()*
                Counts the number of non-nil values in table `t`.
>

    vim.tbl_count({ a=1, b=2 }) => 2
    vim.tbl_count({ 1, 2 }) => 2
<

                Parameters: ~
                    {t}  Table

                Return: ~
                    Number that is the number of the value in table

                See also: ~
                    https://github.com/Tieske/Penlight/blob/master/lua/pl/tablex.lua

tbl_deep_extend({behavior}, {...})                     *vim.tbl_deep_extend()*
                Merges recursively two or more map-like tables.

                Parameters: ~
                    {behavior}  Decides what to do if a key is found in more
                                than one map:
                                • "error": raise an error
                                • "keep": use value from the leftmost map
                                • "force": use value from the rightmost map
                    {...}       Two or more map-like tables.

                See also: ~
                    |tbl_extend()|

tbl_extend({behavior}, {...})                               *vim.tbl_extend()*
                Merges two or more map-like tables.

                Parameters: ~
                    {behavior}  Decides what to do if a key is found in more
                                than one map:
                                • "error": raise an error
                                • "keep": use value from the leftmost map
                                • "force": use value from the rightmost map
                    {...}       Two or more map-like tables.

                See also: ~
                    |extend()|

tbl_filter({func}, {t})                                     *vim.tbl_filter()*
                Filter a table using a predicate function

                Parameters: ~
                    {func}  function or callable table
                    {t}     table

tbl_flatten({t})                                           *vim.tbl_flatten()*
                Creates a copy of a list-like table such that any nested
                tables are "unrolled" and appended to the result.

                Parameters: ~
                    {t}  List-like table

                Return: ~
                    Flattened copy of the given list-like table.

                See also: ~
                    From https://github.com/premake/premake-core/blob/master/src/base/table.lua

tbl_get({o}, {...})                                            *vim.tbl_get()*
                Index into a table (first argument) via string keys passed as
                subsequent arguments. Return `nil` if the key does not exist. Examples: >

                  vim.tbl_get({ key = { nested_key = true }}, 'key', 'nested_key') == true
                  vim.tbl_get({ key = {}}, 'key', 'nested_key') == nil
<

                Parameters: ~
                    {o}    Table to index
                    {...}  Optional strings (0 or more, variadic) via which to
                           index the table

                Return: ~
                    nested value indexed by key if it exists, else nil

tbl_isempty({t})                                           *vim.tbl_isempty()*
                Checks if a table is empty.

                Parameters: ~
                    {t}  Table to check

                See also: ~
                    https://github.com/premake/premake-core/blob/master/src/base/table.lua

tbl_islist({t})                                             *vim.tbl_islist()*
                Tests if a Lua table can be treated as an array.

                Empty table `{}` is assumed to be an array, unless it was
                created by |vim.empty_dict()| or returned as a dict-like |API|
                or Vimscript result, for example from |rpcrequest()| or
                |vim.fn|.

                Parameters: ~
                    {t}  Table

                Return: ~
                    `true` if array-like table, else `false`.

tbl_keys({t})                                                 *vim.tbl_keys()*
                Return a list of all keys used in a table. However, the order
                of the return table of keys is not guaranteed.

                Parameters: ~
                    {t}  Table

                Return: ~
                    list of keys

                See also: ~
                    From https://github.com/premake/premake-core/blob/master/src/base/table.lua

tbl_map({func}, {t})                                           *vim.tbl_map()*
                Apply a function to all values of a table.

                Parameters: ~
                    {func}  function or callable table
                    {t}     table

tbl_values({t})                                             *vim.tbl_values()*
                Return a list of all values used in a table. However, the
                order of the return table of values is not guaranteed.

                Parameters: ~
                    {t}  Table

                Return: ~
                    list of values

trim({s})                                                         *vim.trim()*
                Trim whitespace (Lua pattern "%s") from both sides of a
                string.

                Parameters: ~
                    {s}  String to trim

                Return: ~
                    String with whitespace removed from its beginning and end

                See also: ~
                    https://www.lua.org/pil/20.2.html

validate({opt})                                               *vim.validate()*
                Validates a parameter specification (types and values).

                Usage example: >

                  function user.new(name, age, hobbies)
                    vim.validate{
                      name={name, 'string'},
                      age={age, 'number'},
                      hobbies={hobbies, 'table'},
                    }
                    ...
                  end
<

                Examples with explicit argument values (can be run directly): >

                  vim.validate{arg1={{'foo'}, 'table'}, arg2={'foo', 'string'}}
                     => NOP (success)

                  vim.validate{arg1={1, 'table'}}
                     => error('arg1: expected table, got number')

                  vim.validate{arg1={3, function(a) return (a % 2) == 0 end, 'even number'}}
                     => error('arg1: expected even number, got 3')
<

                If multiple types are valid they can be given as a list. >

                  vim.validate{arg1={{'foo'}, {'table', 'string'}}, arg2={'foo', {'table', 'string'}}}
                     => NOP (success)

                  vim.validate{arg1={1, {'string', table'}}}
                     => error('arg1: expected string|table, got number')
<

                Parameters: ~
                    {opt}  table of parameter names to validations. Each key
                           is a parameter name; each value is a tuple in one
                           of these forms:
                           1. (arg_value, type_name, optional)
                              • arg_value: argument value
                              • type_name: string|table type name, one of:
                                ("table", "t", "string", "s", "number", "n",
                                "boolean", "b", "function", "f", "nil",
                                "thread", "userdata") or list of them.
                              • optional: (optional) boolean, if true, `nil`
                                is valid

                           2. (arg_value, fn, msg)
                              • arg_value: argument value
                              • fn: any function accepting one argument,
                                returns true if and only if the argument is
                                valid. Can optionally return an additional
                                informative error message as the second
                                returned value.
                              • msg: (optional) error string if validation
                                fails


==============================================================================
Lua module: uri                                                      *lua-uri*

uri_from_bufnr({bufnr})                                 *vim.uri_from_bufnr()*
                Get a URI from a bufnr

                Parameters: ~
                    {bufnr}  number

                Return: ~
                    string URI

uri_from_fname({path})                                  *vim.uri_from_fname()*
                Get a URI from a file path.

                Parameters: ~
                    {path}  string Path to file

                Return: ~
                    string URI

uri_to_bufnr({uri})                                       *vim.uri_to_bufnr()*
                Get the buffer for a uri. Creates a new unloaded buffer if no
                buffer for the uri already exists.

                Parameters: ~
                    {uri}  string

                Return: ~
                    number bufnr

uri_to_fname({uri})                                       *vim.uri_to_fname()*
                Get a filename from a URI

                Parameters: ~
                    {uri}  string

                Return: ~
                    string filename or unchanged URI for non-file URIs


==============================================================================
Lua module: ui                                                        *lua-ui*

input({opts}, {on_confirm})                                   *vim.ui.input()*
                Prompts the user for input

                Example: >

                 vim.ui.input({ prompt = 'Enter value for shiftwidth: ' }, function(input)
                     vim.o.shiftwidth = tonumber(input)
                 end)
<

                Parameters: ~
                    {opts}        table Additional options. See |input()|
                                  • prompt (string|nil) Text of the prompt.
                                    Defaults to `Input:`.
                                  • default (string|nil) Default reply to the
                                    input
                                  • completion (string|nil) Specifies type of
                                    completion supported for input. Supported
                                    types are the same that can be supplied to
                                    a user-defined command using the
                                    "-complete=" argument. See
                                    |:command-completion|
                                  • highlight (function) Function that will be
                                    used for highlighting user inputs.
                    {on_confirm}  function ((input|nil) -> ()) Called once the
                                  user confirms or abort the input. `input` is
                                  what the user typed. `nil` if the user
                                  aborted the dialog.

select({items}, {opts}, {on_choice})                         *vim.ui.select()*
                Prompts the user to pick a single item from a collection of
                entries

                Example: >

                 vim.ui.select({ 'tabs', 'spaces' }, {
                     prompt = 'Select tabs or spaces:',
                     format_item = function(item)
                         return "I'd like to choose " .. item
                     end,
                 }, function(choice)
                     if choice == 'spaces' then
                         vim.o.expandtab = true
                     else
                         vim.o.expandtab = false
                     end
                 end)
<

                Parameters: ~
                    {items}      table Arbitrary items
                    {opts}       table Additional options
                                 • prompt (string|nil) Text of the prompt.
                                   Defaults to `Select one of:`
                                 • format_item (function item -> text)
                                   Function to format an individual item from
                                   `items`. Defaults to `tostring`.
                                 • kind (string|nil) Arbitrary hint string
                                   indicating the item shape. Plugins
                                   reimplementing `vim.ui.select` may wish to
                                   use this to infer the structure or
                                   semantics of `items`, or the context in
                                   which select() was called.
                    {on_choice}  function ((item|nil, idx|nil) -> ()) Called
                                 once the user made a choice. `idx` is the
                                 1-based index of `item` within `items`. `nil`
                                 if the user aborted the dialog.


==============================================================================
Lua module: filetype                                            *lua-filetype*

add({filetypes})                                          *vim.filetype.add()*
                Add new filetype mappings.

                Filetype mappings can be added either by extension or by
                filename (either the "tail" or the full file path). The full
                file path is checked first, followed by the file name. If a
                match is not found using the filename, then the filename is
                matched against the list of patterns (sorted by priority)
                until a match is found. Lastly, if pattern matching does not
                find a filetype, then the file extension is used.

                The filetype can be either a string (in which case it is used
                as the filetype directly) or a function. If a function, it
                takes the full path and buffer number of the file as arguments
                (along with captures from the matched pattern, if any) and
                should return a string that will be used as the buffer's
                filetype.

                Filename patterns can specify an optional priority to resolve
                cases when a file path matches multiple patterns. Higher
                priorities are matched first. When omitted, the priority
                defaults to 0.

                See $VIMRUNTIME/lua/vim/filetype.lua for more examples.

                Note that Lua filetype detection is only enabled when
                |g:do_filetype_lua| is set to 1.

                Example: >

                  vim.filetype.add({
                    extension = {
                      foo = "fooscript",
                      bar = function(path, bufnr)
                        if some_condition() then
                          return "barscript"
                        end
                        return "bar"
                      end,
                    },
                    filename = {
                      [".foorc"] = "toml",
                      ["/etc/foo/config"] = "toml",
                    },
                    pattern = {
                      [".*&zwj;/etc/foo/.*"] = "fooscript",
                      -- Using an optional priority
                      [".*&zwj;/etc/foo/.*%.conf"] = { "dosini", { priority = 10 } },
                      ["README.(%a+)$"] = function(path, bufnr, ext)
                        if ext == "md" then
                          return "markdown"
                        elseif ext == "rst" then
                          return "rst"
                        end
                      end,
                    },
                  })
<

                Parameters: ~
                    {filetypes}  table A table containing new filetype maps
                                 (see example).

match({name}, {bufnr})                                  *vim.filetype.match()*
                Set the filetype for the given buffer from a file name.

                Parameters: ~
                    {name}   string File name (can be an absolute or relative
                             path)
                    {bufnr}  number|nil The buffer to set the filetype for.
                             Defaults to the current buffer.


==============================================================================
Lua module: keymap                                                *lua-keymap*

del({modes}, {lhs}, {opts})                                 *vim.keymap.del()*
                Remove an existing mapping. Examples: >

                   vim.keymap.del('n', 'lhs')

                   vim.keymap.del({'n', 'i', 'v'}, '<leader>w', { buffer = 5 })
<

                Parameters: ~
                    {opts}  table A table of optional arguments:
                            • buffer: (number or boolean) Remove a mapping
                              from the given buffer. When "true" or 0, use the
                              current buffer.

                See also: ~
                    |vim.keymap.set()|

set({mode}, {lhs}, {rhs}, {opts})                           *vim.keymap.set()*
                Add a new |mapping|. Examples: >

                   -- Can add mapping to Lua functions
                   vim.keymap.set('n', 'lhs', function() print("real lua function") end)

                   -- Can use it to map multiple modes
                   vim.keymap.set({'n', 'v'}, '<leader>lr', vim.lsp.buf.references, { buffer=true })

                   -- Can add mapping for specific buffer
                   vim.keymap.set('n', '<leader>w', "<cmd>w<cr>", { silent = true, buffer = 5 })

                   -- Expr mappings
                   vim.keymap.set('i', '<Tab>', function()
                     return vim.fn.pumvisible() == 1 and "<C-n>" or "<Tab>"
                   end, { expr = true })
                   -- <Plug> mappings
                   vim.keymap.set('n', '[%', '<Plug>(MatchitNormalMultiBackward)')
<

                Note that in a mapping like: >

                    vim.keymap.set('n', 'asdf', require('jkl').my_fun)
<

                the `require('jkl')` gets evaluated during this call in order to access the
                function. If you want to avoid this cost at startup you can
                wrap it in a function, for example: >

                    vim.keymap.set('n', 'asdf', function() return require('jkl').my_fun() end)
<

                Parameters: ~
                    {mode}  string|table Same mode short names as
                            |nvim_set_keymap()|. Can also be list of modes to
                            create mapping on multiple modes.
                    {lhs}   string Left-hand side |{lhs}| of the mapping.
                    {rhs}   string|function Right-hand side |{rhs}| of the
                            mapping. Can also be a Lua function. If a Lua
                            function and `opts.expr == true`, returning `nil`
                            is equivalent to an empty string.
                    {opts}  table A table of |:map-arguments| such as
                            "silent". In addition to the options listed in
                            |nvim_set_keymap()|, this table also accepts the
                            following keys:
                            • buffer: (number or boolean) Add a mapping to the
                              given buffer. When "true" or 0, use the current
                              buffer.
                            • replace_keycodes: (boolean, default true) When
                              both this and expr is "true",
                              |nvim_replace_termcodes()| is applied to the
                              result of Lua expr maps.
                            • remap: (boolean) Make the mapping recursive.
                              This is the inverse of the "noremap" option from
                              |nvim_set_keymap()|. Default `false`.

                See also: ~
                    |nvim_set_keymap()|

 vim:tw=78:ts=8:ft=help:norl:
