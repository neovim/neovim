-- Older tmux versions support a max of 256 bytes, and the file part transfer
-- outside of content is 17 bytes. Max for newer tmux/iterm2 is 1,048,576 bytes.
-- We're going to stick with the newer byte maximum as the lower is very restrictive.
local ITERM2_MAX_TRANSFER_SIZE = 65536 -- 64KiB

-- Contents sent within an escape sequence make up a portion of the total sequence.
-- This represens the size of the contents section.
local MAX_CONTENTS_SIZE = ITERM2_MAX_TRANSFER_SIZE - 17

---Amount of time to wait between a refresh of neovim's TUI screen and redrawing
---all images managed by the iterm2 provider.
---@type integer
local REDRAW_DELAY_MS = 30

---Creates a hash unique to an image and parameters that need to be fed to Image Magick.
---This is to be able to cache iterm2 data generated by Image Magick.
---@param filename string
---@param opts vim.ui.img.Opts
---@return string
local function img_to_hash(filename, opts)
  ---@type string[]
  local items = {
    filename,
    opts.crop and opts.crop:hash() or '',
    opts.size and opts.size:hash() or '',
  }

  return vim.fn.sha256(table.concat(items))
end

---@class vim.ui.img.providers.Iterm2
---@field private __data table<string, string> mapping of image hash -> iterm2 image data
---@field private __id_cnt integer
---@field private __is_drawing boolean
---@field private __is_tmux boolean
---@field private __placements table<integer, {img:vim.ui.Image, opts:vim.ui.img.Opts, hash:string, redraw:boolean}>
---@field private __redraw_autocmds integer[]
---@field private __redraw_callbacks table<integer, fun(err:string|nil)[]>
---@field private __redraw_clear boolean if true, clears screen on next redraw
---@field private __redraw_timer? uv.uv_timer_t
---@field private __writer vim.ui.img.utils.BatchWriter
local M = {
  __data = {},
  __id_cnt = 0,
  __is_drawing = false,
  __is_tmux = false,
  __placements = {},
  __redraw_autocmds = {},
  __redraw_callbacks = {},
  __redraw_clear = false,
  __redraw_timer = nil,
  __writer = nil, -- To be filled in during load()
}

---@param opts? {write?:fun(...:string)}
function M:load(opts)
  opts = opts or {}

  -- Check if tmux exists, and if so configure it for passthrough of our images
  if vim.env['TMUX'] ~= nil then
    local res = vim.system({ 'tmux', 'set', '-p', 'allow-passthrough', 'all' }):wait()
    assert(res.code == 0, 'failed to "set -p allow-passthrough all" for tmux')
    self.__is_tmux = true
  end

  local utils = require('vim.ui.img.utils')
  self.__writer = utils.new_batch_writer({
    use_chan_send = true,
    map = function(s)
      if self.__is_tmux then
        s = utils.codes.escape_tmux_passthrough(s)
      end
      return s
    end,
    write = opts.write,
  })

  -- Start the engine that will redraw images on a schedule
  self.__redraw_timer = assert(vim.uv.new_timer())
  self.__redraw_timer:start(
    REDRAW_DELAY_MS,
    REDRAW_DELAY_MS,
    vim.schedule_wrap(function()
      self:__redraw()
    end)
  )

  -- For these autocommands, we only need to redraw the images as the images themselves
  -- should not have moved from their position
  table.insert(
    self.__redraw_autocmds,
    vim.api.nvim_create_autocmd({
      'BufEnter',
      'BufWritePost',
      'CursorMoved',
      'CursorMovedI',
      'TextChanged',
      'TextChangedI',
      'VimResized',
      'VimResume',
      'WinEnter',
      'WinNew',
    }, {
      callback = function()
        for _, placement in pairs(self.__placements) do
          placement.redraw = true
        end
      end,
    })
  )

  -- For these autocommands, we need to both clear the screen and redraw all images
  -- as the images may have moved (visually) from their positions
  table.insert(
    self.__redraw_autocmds,
    vim.api.nvim_create_autocmd({ 'WinScrolled' }, {
      callback = function()
        self.__redraw_clear = true
        for _, placement in pairs(self.__placements) do
          placement.redraw = true
        end
      end,
    })
  )
end

function M:unload()
  for _, id in ipairs(self.__redraw_autocmds) do
    pcall(vim.api.nvim_del_autocmd, id)
  end

  if self.__redraw_timer then
    self.__redraw_timer:stop()
  end

  self.__data = {}
  self.__is_drawing = false
  self.__is_tmux = false
  self.__placements = {}
  self.__redraw_autocmds = {}
  self.__redraw_callbacks = {}
  self.__redraw_timer = nil
  self.__writer = nil
end

---@param on_supported fun(supported:boolean)
function M:supported(on_supported)
  -- iterm2's image protocol doesn't have a way to query for support,
  -- so instead we query for cell size using iterm2's proprietary
  -- escape code to see if environment supports any of iterm2's
  -- functionality and assume that if it supports this, then it supports
  -- the image protocol as well
  local promise = require('vim.ui.img.utils').query_term('\027]1337;ReportCellSize\007', {
    -- Not a guarantee that we're loaded when this is called,
    -- so we try to make use of our writer if we are, otherwise
    -- we default to stdout to send our query
    write = self.__writer and self.__writer.write_fast or nil,
  }, function(seq)
    local patterns = {
      -- OSC 1337 ; ReportCellSize=[height];[width] ST
      '\027]1337;ReportCellSize=[%d%.]+;[%d%.]+',
      -- OSC 1337 ; ReportCellSize=[height];[width];[scale] ST
      '\027]1337;ReportCellSize=[%d%.]+;[%d%.]+;[%d%.]+',
    }

    for _, pattern in ipairs(patterns) do
      if string.find(seq, pattern) then
        return true
      end
    end
  end)

  promise:on_ok(on_supported):on_fail(function()
    on_supported(false)
  end)
end

---@param img vim.ui.Image
---@param opts vim.ui.img.Opts
---@param on_shown fun(err:string|nil, id:integer|nil)
function M:show(img, opts, on_shown)
  local id = self:__next_id()
  local hash = img_to_hash(img.filename, opts)

  -- Register the new sixel placement and mark it for being drawn,
  -- which will trigger the data to be loaded the first time it
  -- is needed
  self.__placements[id] = {
    img = img,
    opts = opts,
    hash = hash,
    redraw = true,
  }

  -- NOTE: We assume that the next redraw will include this image
  self:__on_next_redraw(id, function(err)
    if err then
      on_shown(err)
    else
      on_shown(nil, id)
    end
  end)
end

---@param ids integer[]
---@param on_hidden fun(err:string|nil, ids:integer[]|nil)
function M:hide(ids, on_hidden)
  -- For all specified iterm2 placements to be hidden, we just
  -- remove them from our list since they'll be cleared anyway
  for _, id in ipairs(ids) do
    self.__placements[id] = nil
  end

  -- For all remaining iterm2 placements, we need to redraw them
  -- after the screen is cleared
  self.__redraw_clear = true
  for _, placement in pairs(self.__placements) do
    placement.redraw = true
  end

  -- NOTE: We assume that the next redraw will not include these images
  self:__on_next_redraw(ids, function(err)
    if err then
      on_hidden(err)
    else
      on_hidden(nil, ids)
    end
  end)
end

---@param id integer
---@param opts vim.ui.img.Opts
---@param on_updated fun(err:string|nil, id:integer|nil)
function M:update(id, opts, on_updated)
  -- To perform an update, we need to clear the screen
  -- so that the newly-updated placement properly replaces
  -- the old one, which also means having all existing
  -- placements redraw themselves
  self.__redraw_clear = true
  for pid, placement in pairs(self.__placements) do
    placement.redraw = true
    if pid == id then
      placement.opts = opts
    end
  end

  -- NOTE: We assume that the next redraw will include this update
  self:__on_next_redraw(id, function(err)
    if err then
      on_updated(err)
    else
      on_updated(nil, id)
    end
  end)
end

---@private
---@return integer
function M:__next_id()
  self.__id_cnt = self.__id_cnt + 1
  return self.__id_cnt
end

---@private
---@return integer
function M:__get_redraw_cnt()
  local cnt = 0
  for _, placement in pairs(self.__placements) do
    if placement.redraw then
      cnt = cnt + 1
    end
  end
  return cnt
end

---@private
---Retrieves the ids of the placements to redraw, sorted by z index with
---placements that tie in z-index being ordered by lower id < higher id.
---@return integer[]
function M:__get_sorted_redraw_ids()
  ---@type integer[]
  local ids = {}
  local placements = self.__placements

  for id, placement in pairs(placements) do
    if placement.redraw then
      table.insert(ids, id)
    end
  end

  table.sort(ids, function(a, b)
    local az = placements[a].opts.z or 0
    local bz = placements[b].opts.z or 0

    return az < bz or a < b
  end)

  return ids
end

---@private
---Schedules `f` to be executed the next time a redraw occurs for `id`.
---@param ids integer|integer[]
---@param f fun(err:string|nil)
function M:__on_next_redraw(ids, f)
  if type(ids) == 'number' then
    ids = { ids }
  end

  ---@cast ids -integer
  for _, id in ipairs(ids) do
    local callbacks = self.__redraw_callbacks[id] or {}
    table.insert(callbacks, f)
    self.__redraw_callbacks[id] = callbacks
  end
end

---@private
---Invoke all redraw callbacks and then clear the queue.
---@param errs string|table<integer, string>|nil the error(s) during redraw, if any occurred
function M:__trigger_redraw_callbacks(errs)
  local callbacks_by_id = self.__redraw_callbacks
  self.__redraw_callbacks = {}

  if not vim.tbl_isempty(callbacks_by_id) then
    vim.schedule(function()
      for id, callbacks in pairs(callbacks_by_id) do
        for _, f in ipairs(callbacks) do
          ---@type string|nil
          local err

          -- The reported error is either a specific one (id as key)
          -- or a general one (string) if it exists at all
          if type(errs) == 'table' then
            err = errs[id]
          else
            err = errs
          end

          pcall(f, err)
        end
      end
    end)
  end
end

---@private
---Clears the screen if needed.
function M:__clear_screen_if_needed()
  if self.__redraw_clear then
    vim.cmd.mode()
    self.__redraw_clear = false
  end
end

---@private
---@param placement {img:vim.ui.Image, opts:vim.ui.img.Opts, hash:string}
---@param on_load fun(err:string|nil, bytes:string|nil)
function M:__load_placement_image_bytes(placement, on_load)
  local data = self.__data[placement.hash]

  -- If we already have data (transformed or otherwise), we can pass it along
  if data then
    vim.schedule(function()
      on_load(nil, data)
    end)
    return
  end

  -- Otherwise, we need to see if cropping is required, as that will
  -- require using ImageMagick to perform the crop since iterm2's protocol
  -- does not support cropping itself. If no cropping is required, then
  -- we can pass the raw image bytes without needing to invoke ImageMagick.
  local img = placement.img
  local img_bytes = img.bytes
  if placement.opts.crop then
    img:convert({ crop = placement.opts.crop }):on_done(function(err, bytes)
      self.__data[placement.hash] = bytes
      on_load(err, bytes)
    end)
  elseif img_bytes ~= nil then
    self.__data[placement.hash] = img_bytes
    vim.schedule(function()
      on_load(nil, img_bytes)
    end)
  else
    img:reload():on_done(function(err)
      self.__data[placement.hash] = img.bytes
      on_load(err, img.bytes)
    end)
  end
end

---@private
---Redraws all images managed by iterm2 provider.
function M:__redraw()
  if self.__is_drawing then
    return
  end

  -- Get how much we need to redraw, and exit early
  -- if there is nothing to redraw at all
  local redraw_cnt = self:__get_redraw_cnt()
  if redraw_cnt == 0 then
    self:__clear_screen_if_needed()
    self:__trigger_redraw_callbacks()
    return
  end

  -- At this point, we can be considered drawing
  self.__is_drawing = true

  local utils = require('vim.ui.img.utils')
  local writer = self.__writer
  writer.clear()

  -- Save the current state of termsync before we force it off in order
  -- to manually leverage synchronized mode to combine neovim rendering
  -- with our image rendering for a smooth experience
  ---@type boolean
  local old_termsync = vim.o.termsync
  local function restore_state()
    writer.write_fast(utils.codes.SYNC_MODE_DISABLE)
    vim.o.termsync = old_termsync
    self.__is_drawing = false
  end

  ---@type boolean, string|nil
  local ok, err = pcall(function()
    -- Disable termsync and manually start sync mode
    vim.o.termsync = false
    writer.write_fast(utils.codes.SYNC_MODE_ENABLE)

    -- Hide the cursor and save where it is to be restored
    writer.write(utils.codes.CURSOR_HIDE, utils.codes.CURSOR_SAVE)

    ---@type table<integer, string>
    local errs = {}

    ---@param err? {id:integer, msg:string} error information if it occurred
    local function mark_redraw_done(err)
      redraw_cnt = redraw_cnt - 1

      if err then
        errs[err.id] = err.msg
      end

      if redraw_cnt <= 0 then
        writer.write(utils.codes.CURSOR_RESTORE, utils.codes.CURSOR_SHOW)

        -- Clear the screen of all iterm2 images only if needed
        self:__clear_screen_if_needed()

        -- Schedule the output with enough time for the screen clear to finish
        vim.defer_fn(function()
          writer.flush()
          restore_state()
          self:__trigger_redraw_callbacks(errs)
        end, REDRAW_DELAY_MS)
      end
    end

    ---@param filename string
    ---@param bytes string
    ---@param opts vim.ui.img.Opts
    local function draw_image(filename, bytes, opts)
      local name = vim.base64.encode(vim.fn.fnamemodify(filename, ':t:r'))
      local contents = vim.base64.encode(bytes)
      local args = {
        string.format('name=%s', name),
        string.format('size=%s', string.len(bytes)),
        'preserveAspectRatio=0',
        'inline=1',
      }

      if opts.size then
        table.insert(
          args,
          string.format('width=%s' .. (opts.size.unit == 'pixel' and 'px' or ''), opts.size.width)
        )
        table.insert(
          args,
          string.format('height=%s' .. (opts.size.unit == 'pixel' and 'px' or ''), opts.size.height)
        )
      end

      local args_str = table.concat(args, ';')
      local pos = opts:position():to_cells()
      writer.write(utils.codes.move_cursor({ col = pos.x, row = pos.y }))

      if self.__is_tmux then
        writer.write_format('\027]1337;MultipartFile=%s\007', args_str)

        local i = 1
        while i < string.len(contents) do
          writer.write_format(
            '\027]1337;FilePart=%s\007',
            string.sub(contents, i, i + MAX_CONTENTS_SIZE - 1)
          )
          i = i + MAX_CONTENTS_SIZE
        end

        writer.write('\027]1337;FileEnd\007')
      else
        writer.write_format('\027]1337;File=%s:%s\007', args_str, contents)
      end

      mark_redraw_done()
    end

    for _, id in ipairs(self:__get_sorted_redraw_ids()) do
      local placement = self.__placements[id]
      placement.redraw = false

      self:__load_placement_image_bytes(placement, function(err, bytes)
        if err or not bytes then
          mark_redraw_done({
            id = id,
            msg = err or 'failed to load image bytes',
          })
        else
          draw_image(placement.img.filename, bytes, placement.opts)
        end
      end)
    end
  end)

  if not ok then
    err = err or 'iterm2 redraw unknown error'
    vim.notify(err, vim.log.levels.WARN)
    restore_state()
    self:__trigger_redraw_callbacks(err)
  end
end

return require('vim.ui.img.providers').new({
  load = function(...)
    return M:load(...)
  end,
  unload = function()
    return M:unload()
  end,
  supported = function(on_supported)
    return M:supported(on_supported)
  end,
  show = function(img, opts, on_shown)
    return M:show(img, opts, on_shown)
  end,
  hide = function(ids, on_hidden)
    return M:hide(ids, on_hidden)
  end,
  update = function(id, opts, on_updated)
    return M:update(id, opts, on_updated)
  end,
})
