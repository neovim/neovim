.TH XXD 1 "August 1996" "Manual page for xxd"
.\"
.\" 21st May 1996
.\" Man page author:
.\"    Tony Nugent <tony@sctnugen.ppp.gu.edu.au> <T.Nugent@sct.gu.edu.au>
.\"    Changes by Bram Moolenaar <Bram@vim.org>
.SH 名前
.I xxd
\- 16 進ダンプを作成したり、元に戻したり。
.SH 書式
.B xxd
\-h[elp]
.br
.B xxd
[options] [infile [outfile]]
.br
.B xxd
\-r[evert] [options] [infile [outfile]]
.SH 説明
ファイルや標準入力から 16 進ダンプを作成します。
16 進ダンプから元のバイナリに戻すこともできます。
.BR uuencode (1)
や
.BR uudecode (1)
のように、バイナリデータを、メールに貼り付け可能な ASCII 形式に変換できた
り、標準出力に出力することもできます。
さらに、バイナリファイルにパッチを当てるという使い方もできます。
.SH オプション
.I infile
を指定しなかった場合は、標準入力が読み込まれます。
.I infile
に
.RB \` \- '
を指定した場合も、標準入力から読み込まれます。
.I outfile
を指定しなかった (または
.RB \` \- '
を指定した) 場合は、標準出力に出力されます。
.PP
引数の解釈処理は適当なので注意してください。パラメータを取らない引数は
最初の一文字だけチェックされます。
引数の文字とパラメータの間のスペースは省略可能です。
パラメータは 10 進数、16 進数、8 進数で指定できます。
.BR \-c8
、
.BR "\-c 8"
、
.B \-c 010
、
.B \-cols 8
はすべて同じ意味です。
.PP
.TP
.IR \-a " | " \-autoskip
オートスキップ: 連続した nul 行を一つの '*' で置き換える。
.TP
.IR \-b " | " \-bits
ビット (2進数) ダンプ。
1 オクテットが "1" と "0" の 8 文字で出力されます。
各行の行頭には 16 進数の行番号が表示されます。
行末には ascii (または ebcdic) で表した場合の文字が表示されます。
このモードでは \-r、\-p、\-i は機能しません。
.TP
.IR "\-c cols " | " \-cols cols"
一行
.RI < cols >
オクテットで出力する。標準設定は 16 (\-i: 12, \-ps: 30, \-b: 6)。最大 256。
.TP
.IR \-E " | " \-EBCDIC
右端に出力される文字のエンコーディングを ASCII から EBCDIC に変更する。
16 進ダンプの出力形式は変更されません。
\-r、\-p、\-i が同時に指定された場合は何の効果もありません。
.TP
.IR "\-g bytes " | " \-groupsize bytes"
出力を
.RI < bytes >
バイト (2 文字の 16 進数、または 8 文字の 2 進数) ごとにスペースで区切りま
す。
区切らずに出力するには
.I \-g 0
を指定してください。
.RI < Bytes >
の標準設定は \fI2\fP です。2 進ダンプの場合は \fI1\fP です。
ポストスクリプト形式やインクルード形式で出力するときは、このオプションは使わ
れません。
.TP
.IR \-h " | " \-help
コマンドの説明を出力して終了する。変換は実行されません。
.TP
.IR \-i " | " \-include
C インクルードファイル形式で出力します。入力ファイルの名前が付けられた静的配
列の定義が出力されます。標準入力の場合は定義の中身だけ出力されます。
.TP
.IR "\-l len " | " \-len len"
.RI  < len >
オクテットだけ出力する。
.TP
.IR \-p " | " \-ps " | " \-postscript " | " \-plain
ポストスクリプト形式の 16 進ダンプを出力する。別名 プレーン 16 進ダンプ。
.TP
.IR \-r " | " \-revert
元に戻す: 16 進ダンプからバイナリ形式に変換 (またはパッチ) します。
ファイルへ出力する場合、出力先のファイルは切り詰めされません。
行番号や特定の書式がないプレーン 16 進ダンプを読み込む場合は、
.I \-r \-p
を指定してください。空白と改行は無視されます。
.TP
.I \-seek offset
.IR \-r
の後で使われた場合: 16 進ダンプを出力するファイルの位置に
.RI < offset >
を加える。
.TP
.I \-s [+][\-]seek
infile の
.RI < seek >
バイト目 (絶対位置、または相対位置) から開始する。
\fI+ \fRは、現在の標準入力の位置から相対的な位置を示します
(標準入力から読み込むときのみ意味があります)。\fI\- \fRは、入力の終わりから
の文字数を示します (\fI+\fR と同時に指定した場合は、現在の標準入力の位置から
手前の位置を示します)。
\-s 引数を指定しなかった場合は、現在のファイル位置から開始されます。
.TP
.I \-u
16 進数の表記に大文字を使います。指定がない場合は小文字で出力されます。
.TP
.IR \-v " | " \-version
バージョンを表示します。
.SH 警告
.PP
.I xxd \-r
では行番号の評価に関しての暗黙のルールがいくつかあります。
出力ファイルがシーク可能なら、各行の行番号が順番通りに並んでなくても構いませ
ん。位置が飛んでいても重なっていても大丈夫です。その場合、次の位置に移動する
ために lseek(2) が使われます。
出力ファイルがシーク不可なら、「隙間」だけが処理可能です。隙間は null バイト
で埋められます。
.PP
.I xxd \-r
は不正な入力をエラーにしません。ゴミは静かに読み飛ばされます。
.PP
16 進ダンプを編集するときは注意が必要です。
.I xxd \-r
は必要な桁 (\-c 引数参照) だけ 16 進データを読み込んで、行の残りを無視しま
す。つまり、ascii (または ebcdic) を示している列への変更は無視されます。
xxd \-r \-p でプレーン形式 (ポストスクリプト形式) の 16 進ダンプを元に戻す場
合は、列の数は影響しません。
2 桁の 16 進数と認識できるものはすべて変換されます。
.PP
\fI% xxd \-i file\fR
.br
と
.br
\fI% xxd \-i < file\fR
.br
の結果は違います。注意してください。
.PP
.I xxd \-s +seek
と
.IR "xxd \-s seek" ,
の違いは、lseek(2) を使って入力を "巻き戻す" かどうかです。'+' が意味を持つ
のは、入力が標準入力で、xxd が起動されたときに標準入力のファイル位置がファイ
ルの先頭ではなかった場合です。
以下の例が分かりやすいかもしれません (もっと混乱するかも!)...
.PP
`cat' が既に標準入力を終わりまで読んでいるので、読む前に標準入力を巻き戻す必
要がある。
.br
\fI% sh \-c "cat > plain_copy; xxd \-s 0 > hex_copy" < file\fR
.PP
ファイル位置 0x480 (=1024+128) 前方から 16 進ダンプする。
`+' は 「現在地からの相対位置」を意味するので、dd が 1k 処理した後から、さら
に `128' 進めます。
.br
\fI% sh \-c "dd of=plain_snippet bs=1k count=1; xxd \-s +128 > hex_snippet" < file\fR
.PP
ファイル位置 0x100 ( = 1024\-768) から 16 進ダンプする。
.br
\fI% sh \-c "dd of=plain_snippet bs=1k count=1; xxd \-s +\-768 > hex_snippet" < file\fR
.PP
このような使い方はあまりしませんし、`+' を使うこともほとんどないでしょう。
\-s を使うときはいつでも、strace(1) や truss(1) を使って、xxd の働きをチェッ
クすることをお勧めします。
.SH 例
.PP
.br
.BR ファイル
の最初の三行 (16 進数で 0x30 バイト) 以降を出力する。
.br
\fI% xxd \-s 0x30 file\fR
.PP
.br
.BR ファイル
の最後から三行 (16 進数で 0x30 バイト) を出力する。
.br
\fI% xxd \-s \-0x30 file\fR
.PP
.br
120 バイトを、平文 16 進ダンプ形式で一行に 20 オクテットずつ出力する。
.br
\fI% xxd \-l 120 \-ps \-c 20 xxd.1\fR
.br
2e54482058584420312022417567757374203139
.br
39362220224d616e75616c207061676520666f72
.br
20787864220a2e5c220a2e5c222032317374204d
.br
617920313939360a2e5c22204d616e2070616765
.br
20617574686f723a0a2e5c2220202020546f6e79
.br
204e7567656e74203c746f6e79407363746e7567
.br

.br
この man ページの先頭から 120 バイトを一行に 12 オクテットずつ 16 進ダンプす
る。
.br
\fI% xxd \-l 120 \-c 12 xxd.1\fR
.br
0000000: 2e54 4820 5858 4420 3120 2241  .TH XXD 1 "A
.br
000000c: 7567 7573 7420 3139 3936 2220  ugust 1996" 
.br
0000018: 224d 616e 7561 6c20 7061 6765  "Manual page
.br
0000024: 2066 6f72 2078 7864 220a 2e5c   for xxd"..\\
.br
0000030: 220a 2e5c 2220 3231 7374 204d  "..\\" 21st M
.br
000003c: 6179 2031 3939 360a 2e5c 2220  ay 1996..\\" 
.br
0000048: 4d61 6e20 7061 6765 2061 7574  Man page aut
.br
0000054: 686f 723a 0a2e 5c22 2020 2020  hor:..\\"    
.br
0000060: 546f 6e79 204e 7567 656e 7420  Tony Nugent 
.br
000006c: 3c74 6f6e 7940 7363 746e 7567  <tony@sctnug
.PP
.br
xxd.1 の日付部分だけを出力する。
.br
\fI% xxd \-s 0x36 \-l 13 \-c 13 xxd.1\fR
.br
0000036: 3231 7374 204d 6179 2031 3939 36  21st May 1996
.PP
.br
.B input_file
を
.B output_file
にコピーし、先頭に 0x00 を 100 バイト分付け加える。
.br
\fI% xxd input_file | xxd \-r \-s 100 > output_file\fR
.br

.br
xxd.1 の日付を修正する。
.br
\fI% echo "0000037: 3574 68" | xxd \-r \- xxd.1\fR
.br
\fI% xxd \-s 0x36 \-l 13 \-c 13 xxd.1\fR
.br
0000036: 3235 7468 204d 6179 2031 3939 36  25th May 1996
.PP
.br
中身がすべて 0x00 の 65537 バイトのファイルを作成する。
ただし、最後のバイトだけは 'A' (hex 0x41)。
.br
\fI% echo "010000: 41" | xxd \-r > file\fR
.PP
.br
作成したファイルをオートスキップを使って 16 進ダンプする。
.br
\fI% xxd \-a \-c 12 file\fR
.br
0000000: 0000 0000 0000 0000 0000 0000  ............
.br
*
.br
000fffc: 0000 0000 40                   ....A
.PP
一文字の 'A' からなる 1 バイトのファイルを作成する。
 '\-r \-s' の後に指定した数値がファイル中の行番号に加算され、結果、余計なバ
イトが飛ばされる。
.br
\fI% echo "010000: 41" | xxd \-r \-s \-0x10000 > file\fR
.PP
.B vim(1)
の中から xxd をフィルタとして実行し、
マークされた `a' から `z' までの領域を 16 進ダンプする。
.br
\fI:'a,'z!xxd\fR
.PP
.B vim(1)
の中から xxd をフィルタとして実行し、
マークされた `a' から `z' までの領域をバイナリに戻す。
.br
\fI:'a,'z!xxd \-r\fR
.PP
.B vim(1)
の中から xxd をフィルタとして実行し、
16 進ダンプされた行を元に戻す。戻したい行にカーソルを移動して:
.br
\fI!!xxd \-r\fR
.PP
シリアル行から一文字読み込む
.br
\fI% xxd \-c1 < /dev/term/b &\fR
.br
\fI% stty < /dev/term/b \-echo \-opost \-isig \-icanon min 1\fR
.br
\fI% echo \-n foo > /dev/term/b\fR
.PP
.SH 返り値
以下のエラー値が返ります:
.TP
0
エラーなし。
.TP
\-1
操作がサポートされていない (
.I xxd \-r \-i
はまだ不可です)。
.TP
1
引数の解釈に関するエラー。
.TP
2
入力ファイルに関する問題。
.TP
3
出力ファイルに関する問題。
.TP
4,5
指定された位置へシークできなかった。
.SH 関連項目
uuencode(1), uudecode(1), patch(1)
.br
.SH 警告
この奇妙なツールは作者が使いやすいように作られています。
自己責任で使ってください。ファイルをコピーし、それを調べ、ウィザードたれ。
.br
.SH バージョン
このマニュアルは xxd バージョン 1.7 について説明しています。
.SH 著者
.br
(c) 1990-1997 by Juergen Weigert
.br
<jnweiger@informatik.uni\-erlangen.de>
.LP
私の功績として自由に配布してください。
.br
儲かったら教えてください。
.br
損しても知りません。
.PP
マニュアルは Tony Nugent
.br
<tony@sctnugen.ppp.gu.edu.au> <T.Nugent@sct.gu.edu.au>
.br
によって書かれ、
Bram Moolenaar が少し変更を加え、
Juergen Weigert が編集しました。
.PP
