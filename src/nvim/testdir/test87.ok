start:
[1, 'as''d', [1, 2, function('strlen'), {'a': 1}]]
[1, 2, function('strlen'), {'a': 1}]
Vim(put):E684:
[0, 'as''d', [1, 2, function('strlen'), {'a': 1}]]
[0, function('strlen'), [1, 2, function('strlen'), {'a': 1}]]
1
[b'-1', b'0', b'1', b'b', b'f']
[-1, <vim.Function '1'>, <vim.dictionary object at >, <vim.list object at >, b'asd']
[(b'-1', <vim.dictionary object at >), (b'0', -1), (b'1', b'asd'), (b'b', <vim.list object at >), (b'f', <vim.Function '1'>)]
'-1' : {'a': 1}
'0' : -1
'1' : 'asd'
'b' : [1, 2, function('strlen')]
'f' : function('1')
[0, function('strlen')]
[3]
[1, 2, function('strlen')]
[1, 2, function('strlen')]
1
'asd'
2
True
False
True
False
[b'0']
{'0': -1}
(b'0', -1)
None
[]
[0, 1, 2, 3]
[0, 1, 2, 3]
[0, 1, 3]
[0, 1]
[0, 1]
[0, 1]
[0, 1, 2, 3]
[0, 1, 2, 3]
[0, 2, 3]
[2, 3]
[2, 3]
[2, 3]
[1, 3]
[0, 2]
[0, 1, 2, 3]
['a', 0, 1, 2, 3]
[0, 'b', 2, 3]
[0, 1, 'c']
[0, 1, 2, 3, 'd']
[0, 1, 2, 'e', 3]
['f', 2, 3]
[0, 1, 'g', 2, 3]
['h']
[0, 1, 10, 3, 20, 5, 6, 7]
[0, 1, 2, 3, 20, 5, 10, 7]
[0, 1, 2, 3, 4, 5, 6, 7]
[0, 1, 2, 3, 4, 5, 6, 7]
[0, 1, 2, 3, 4, 5, 6, 7]
[0, 1, 2, 3]
[function('New'), function('DictNew'), 'NewStart', 1, 2, 3, 'NewEnd']
[function('New'), function('DictNew'), 'NewStart', 1, 2, 3, 'NewEnd', 'DictNewStart', 1, 2, 3, 'DictNewEnd', {'a': 'b'}]
[function('New'), function('DictNew'), 'NewStart', 1, 2, 3, 'NewEnd', 'DictNewStart', 1, 2, 3, 'DictNewEnd', {'a': 'b'}, 'New']
l[1](1, 2, 3):(<class 'vim.error'>, error('Vim:E725: Calling dict function without Dictionary: DictNew',))
f(1, 2, 3):(<class 'vim.error'>, error('Vim:E117: Unknown function: New',))
[0.0, 0.0]
KeyError
TypeError
TypeError
ValueError
TypeError
TypeError
KeyError
KeyError
d : locked:0;scope:0
dl : locked:1;scope:0
v: : locked:2;scope:1
g: : locked:0;scope:2
d:{'abc2': 1}
dl:{'def': 1}
l : locked:0
ll : locked:1
l:[0]
ll:[1]
[0, 1, 2]
['a', 'b']
['c', 1]
['d', ['e']]
0.0
"\0":	Vim(let):E859:
{"\0": 1}:	Vim(let):E859:
undefined_name:	Vim(let):Trace
vim:	Vim(let):E859:
[1]
[1, 10, 11, 10, 11, 10, 11, 10, 11, 10, 11, 10, 1]
[0, 1, 2, 3]
[2, 3, 4, 5]
[0, 1]
[4, 5]
[2, 3]
[]
[2, 3]
[]
[0, 1, 2, 3, 4, 5]
[0, 1, 2, 3, 4, 5]
[0, 1, 2, 3, 4, 5]
[4, 3]
[0, 2, 4]
[]
Abc
bac
def
bar
jkl
wopts iters equal: 1
bopts iters equal: 1
>>> paste
  g/w/b:1/0/0
  g/w/b (in):1/0/0
  p/gopts1: False
  p/wopts1! KeyError
  inv: 2! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1! KeyError
  inv: 2! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: 1
  W: 1:1 2:1 3:1 4:1
  B: 1:1 2:1 3:1 4:1
  del wopts3! KeyError
  del bopts3! KeyError
  G: 1
  W: 1:1 2:1 3:1 4:1
  B: 1:1 2:1 3:1 4:1
>>> previewheight
  g/w/b:1/0/0
  g/w/b (in):1/0/0
  p/gopts1: 12
  inv: 'a'! TypeError
  p/wopts1! KeyError
  inv: 'a'! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1! KeyError
  inv: 'a'! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: 5
  W: 1:5 2:5 3:5 4:5
  B: 1:5 2:5 3:5 4:5
  del wopts3! KeyError
  del bopts3! KeyError
  G: 5
  W: 1:5 2:5 3:5 4:5
  B: 1:5 2:5 3:5 4:5
>>> operatorfunc
  g/w/b:1/0/0
  g/w/b (in):1/0/0
  p/gopts1: b''
  inv: 2! TypeError
  p/wopts1! KeyError
  inv: 2! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1! KeyError
  inv: 2! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: 'A'
  W: 1:'A' 2:'A' 3:'A' 4:'A'
  B: 1:'A' 2:'A' 3:'A' 4:'A'
  del wopts3! KeyError
  del bopts3! KeyError
  G: 'A'
  W: 1:'A' 2:'A' 3:'A' 4:'A'
  B: 1:'A' 2:'A' 3:'A' 4:'A'
>>> number
  g/w/b:0/1/0
  g/w/b (in):0/1/0
  p/gopts1! KeyError
  inv: 0! KeyError
  gopts1! KeyError
  p/wopts1: False
  p/bopts1! KeyError
  inv: 0! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: 0
  W: 1:1 2:1 3:0 4:0
  B: 1:1 2:1 3:0 4:0
  del wopts3! ValueError
  del bopts3! KeyError
  G: 0
  W: 1:1 2:1 3:0 4:0
  B: 1:1 2:1 3:0 4:0
>>> numberwidth
  g/w/b:0/1/0
  g/w/b (in):0/1/0
  p/gopts1! KeyError
  inv: -100! KeyError
  gopts1! KeyError
  p/wopts1: 8
  inv: -100! error
  p/bopts1! KeyError
  inv: -100! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: 8
  W: 1:3 2:5 3:2 4:8
  B: 1:3 2:5 3:2 4:8
  del wopts3! ValueError
  del bopts3! KeyError
  G: 8
  W: 1:3 2:5 3:2 4:8
  B: 1:3 2:5 3:2 4:8
>>> colorcolumn
  g/w/b:0/1/0
  g/w/b (in):0/1/0
  p/gopts1! KeyError
  inv: 'abc4'! KeyError
  gopts1! KeyError
  p/wopts1: b''
  inv: 'abc4'! error
  p/bopts1! KeyError
  inv: 'abc4'! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: ''
  W: 1:'+2' 2:'+3' 3:'+1' 4:''
  B: 1:'+2' 2:'+3' 3:'+1' 4:''
  del wopts3! ValueError
  del bopts3! KeyError
  G: ''
  W: 1:'+2' 2:'+3' 3:'+1' 4:''
  B: 1:'+2' 2:'+3' 3:'+1' 4:''
>>> statusline
  g/w/b:1/1/0
  g/w/b (in):1/1/0
  p/gopts1: b''
  inv: 0! TypeError
  p/wopts1: None
  inv: 0! TypeError
  p/bopts1! KeyError
  inv: 0! KeyError
  bopts1! KeyError
  bopts2! KeyError
  bopts3! KeyError
  G: '1'
  W: 1:'2' 2:'4' 3:'1' 4:'1'
  B: 1:'2' 2:'4' 3:'1' 4:'1'
  del bopts3! KeyError
  G: '1'
  W: 1:'2' 2:'1' 3:'1' 4:'1'
  B: 1:'2' 2:'1' 3:'1' 4:'1'
>>> autoindent
  g/w/b:0/0/1
  g/w/b (in):0/0/1
  p/gopts1! KeyError
  inv: 2! KeyError
  gopts1! KeyError
  p/wopts1! KeyError
  inv: 2! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1: False
  G: 0
  W: 1:0 2:1 3:0 4:1
  B: 1:0 2:1 3:0 4:1
  del wopts3! KeyError
  del bopts3! ValueError
  G: 0
  W: 1:0 2:1 3:0 4:1
  B: 1:0 2:1 3:0 4:1
>>> shiftwidth
  g/w/b:0/0/1
  g/w/b (in):0/0/1
  p/gopts1! KeyError
  inv: 3! KeyError
  gopts1! KeyError
  p/wopts1! KeyError
  inv: 3! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1: 8
  G: 8
  W: 1:0 2:2 3:8 4:1
  B: 1:0 2:2 3:8 4:1
  del wopts3! KeyError
  del bopts3! ValueError
  G: 8
  W: 1:0 2:2 3:8 4:1
  B: 1:0 2:2 3:8 4:1
>>> omnifunc
  g/w/b:0/0/1
  g/w/b (in):0/0/1
  p/gopts1! KeyError
  inv: 1! KeyError
  gopts1! KeyError
  p/wopts1! KeyError
  inv: 1! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1: b''
  inv: 1! TypeError
  G: ''
  W: 1:'A' 2:'B' 3:'' 4:'C'
  B: 1:'A' 2:'B' 3:'' 4:'C'
  del wopts3! KeyError
  del bopts3! ValueError
  G: ''
  W: 1:'A' 2:'B' 3:'' 4:'C'
  B: 1:'A' 2:'B' 3:'' 4:'C'
>>> preserveindent
  g/w/b:0/0/1
  g/w/b (in):0/0/1
  p/gopts1! KeyError
  inv: 2! KeyError
  gopts1! KeyError
  p/wopts1! KeyError
  inv: 2! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1: False
  G: 0
  W: 1:0 2:1 3:0 4:1
  B: 1:0 2:1 3:0 4:1
  del wopts3! KeyError
  del bopts3! ValueError
  G: 0
  W: 1:0 2:1 3:0 4:1
  B: 1:0 2:1 3:0 4:1
>>> path
  g/w/b:1/0/1
  g/w/b (in):1/0/1
  p/gopts1: b'.,..,,'
  inv: 0! TypeError
  p/wopts1! KeyError
  inv: 0! KeyError
  wopts1! KeyError
  wopts2! KeyError
  wopts3! KeyError
  p/bopts1: None
  inv: 0! TypeError
  G: '.,,'
  W: 1:'.,,' 2:',,' 3:'.,,' 4:'.'
  B: 1:'.,,' 2:',,' 3:'.,,' 4:'.'
  del wopts3! KeyError
  G: '.,,'
  W: 1:'.,,' 2:',,' 3:'.,,' 4:'.,,'
  B: 1:'.,,' 2:',,' 3:'.,,' 4:'.,,'
First line
First line
def
First line
Second line
Third line
(7, 2)
<buffer test87.in><buffer >
baz
bar
Second line
Third line
foo
1:BufFilePre:1
1:BufFilePost:1
testdir/foo
5:BufFilePre:5
5:BufFilePost:5
testdir/bar
1:BufFilePre:1
1:BufFilePost:1
testdir/test87.in
valid: b:False, cb:True
i:<buffer test87.in>
i2:<buffer test87.in>
i:<buffer a>
i3:<buffer test87.in>
1:<buffer test87.in>=<buffer test87.in>
8:<buffer a>=<buffer a>
9:<buffer b>=<buffer b>
10:<buffer c>=<buffer c>
4
i4:<buffer test87.in>
i4:<buffer test87.in>
StopIteration
Number of tabs: 4
Current tab pages:
  <tabpage 0>(1): 1 windows, current is <window object (unknown)>
  Windows:
    <window object (unknown)>(1): displays buffer <buffer test87.in>; cursor is at (37, 0)
  <tabpage 1>(2): 1 windows, current is <window object (unknown)>
  Windows:
    <window object (unknown)>(1): displays buffer <buffer 0>; cursor is at (1, 0)
  <tabpage 2>(3): 2 windows, current is <window object (unknown)>
  Windows:
    <window object (unknown)>(1): displays buffer <buffer a.1>; cursor is at (1, 0)
    <window object (unknown)>(2): displays buffer <buffer 1>; cursor is at (1, 0)
  <tabpage 3>(4): 4 windows, current is <window 0>
  Windows:
    <window 0>(1): displays buffer <buffer c.2>; cursor is at (1, 0)
    <window 1>(2): displays buffer <buffer b.2>; cursor is at (1, 0)
    <window 2>(3): displays buffer <buffer a.2>; cursor is at (1, 0)
    <window 3>(4): displays buffer <buffer 2>; cursor is at (1, 0)
Number of windows in current tab page: 4
Current tab page: <tabpage 3>
Current window: <window 0>: <window 0> is <window 0>
Current buffer: <buffer c.2>: <buffer c.2> is <buffer c.2> is <buffer c.2>
ValueError at assigning foreign tab window
Type error at assigning None to vim.current.window
Type error at assigning None to vim.current.tabpage
Type error at assigning None to vim.current.buffer
Current tab page: <tabpage 2>
Current window: <window 0>
Current buffer: <buffer test87.in>
Current line: 'Type error at assigning None to vim.current.buffer'
w.valid: [True, False]
t.valid: [True, False, True, False]
vim.vars:Dictionary:True
vim.options:Options:True
vim.bindeval("{}"):Dictionary:True
vim.bindeval("[]"):List:True
vim.bindeval("function('tr')"):Function:True
vim.current.buffer:Buffer:True
vim.current.range:Range:True
vim.current.window:Window:True
vim.current.tabpage:TabPage:True
current:__dir__,buffer,line,range,tabpage,window
buffer:__dir__,append,mark,name,number,options,range,valid,vars
window:__dir__,buffer,col,cursor,height,number,options,row,tabpage,valid,vars
tabpage:__dir__,number,valid,vars,window,windows
range:__dir__,append,end,start
dictionary:__dir__,get,has_key,items,keys,locked,pop,popitem,scope,update,values
list:__dir__,extend,locked
function:__dir__,softspace
output:__dir__,flush,softspace,write,writelines
{}
{'a': 1}
{'a': 1}
[]
['a', 'b', 'c', '7']
function('tr')
'
abcdef
line  :
abcdef
abcA
line  :
abcB'
['a', 'dup_a']
['a', 'a']
['a', 'b', 'c', 'C']
[2, 2]
[2, 2]
1
1
function('Put')
b'testdir'
test87.in
b'src'
testdir/test87.in
b'testdir'
test87.in
> Output
>> OutputSetattr
del sys.stdout.softspace:(<class 'AttributeError'>, AttributeError("can't delete OutputObject attributes",))
>>> Testing NumberToLong using sys.stdout.softspace = %s
sys.stdout.softspace = []:(<class 'TypeError'>, TypeError('expected int() or something supporting coercing to int(), but got list',))
sys.stdout.softspace = None:(<class 'TypeError'>, TypeError('expected int() or something supporting coercing to int(), but got NoneType',))
sys.stdout.softspace = -1:(<class 'ValueError'>, ValueError('number must be greater or equal to zero',))
<<< Finished
>>> Testing NumberToLong using sys.stderr.softspace = %s
sys.stderr.softspace = []:(<class 'TypeError'>, TypeError('expected int() or something supporting coercing to int(), but got list',))
sys.stderr.softspace = None:(<class 'TypeError'>, TypeError('expected int() or something supporting coercing to int(), but got NoneType',))
sys.stderr.softspace = -1:(<class 'ValueError'>, ValueError('number must be greater or equal to zero',))
<<< Finished
sys.stdout.attr = None:(<class 'AttributeError'>, AttributeError('invalid attribute: attr',))
>> OutputWrite
sys.stdout.write(None):(<class 'TypeError'>, TypeError("Can't convert 'NoneType' object to str implicitly",))
>> OutputWriteLines
sys.stdout.writelines(None):(<class 'TypeError'>, TypeError("'NoneType' object is not iterable",))
sys.stdout.writelines([1]):(<class 'TypeError'>, TypeError("Can't convert 'int' object to str implicitly",))
>>> Testing *Iter* using sys.stdout.writelines(%s)
sys.stdout.writelines(FailingIter()):(<class 'NotImplementedError'>, NotImplementedError('iter',))
sys.stdout.writelines(FailingIterNext()):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
> VimCommand
>>> Testing StringToChars using vim.command(%s)
vim.command(1):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
vim.command(b"\0"):(<class 'TypeError'>, TypeError('expected bytes with no null',))
vim.command("\0"):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
vim.command("", 2):(<class 'TypeError'>, TypeError('command() takes exactly one argument (2 given)',))
> VimToPython
> VimEval
>>> Testing StringToChars using vim.eval(%s)
vim.eval(1):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
vim.eval(b"\0"):(<class 'TypeError'>, TypeError('expected bytes with no null',))
vim.eval("\0"):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
vim.eval("", FailingTrue()):(<class 'TypeError'>, TypeError('function takes exactly 1 argument (2 given)',))
> VimEvalPy
>>> Testing StringToChars using vim.bindeval(%s)
vim.bindeval(1):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
vim.bindeval(b"\0"):(<class 'TypeError'>, TypeError('expected bytes with no null',))
vim.bindeval("\0"):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
vim.eval("", 2):(<class 'TypeError'>, TypeError('function takes exactly 1 argument (2 given)',))
> VimStrwidth
>>> Testing StringToChars using vim.strwidth(%s)
vim.strwidth(1):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
vim.strwidth(b"\0"):(<class 'TypeError'>, TypeError('expected bytes with no null',))
vim.strwidth("\0"):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
> VimForeachRTP
vim.foreach_rtp(None):(<class 'TypeError'>, TypeError("'NoneType' object is not callable",))
vim.foreach_rtp(NoArgsCall()):(<class 'TypeError'>, TypeError('__call__() takes exactly 1 positional argument (2 given)',))
vim.foreach_rtp(FailingCall()):(<class 'NotImplementedError'>, NotImplementedError('call',))
vim.foreach_rtp(int, 2):(<class 'TypeError'>, TypeError('foreach_rtp() takes exactly one argument (2 given)',))
> import
import xxx_no_such_module_xxx:(<class 'ImportError'>, ImportError('No module named xxx_no_such_module_xxx',))
import failing_import:(<class 'ImportError'>, ImportError('No module named failing_import',))
import failing:(<class 'NotImplementedError'>, NotImplementedError())
> Options
>> OptionsItem
vim.options["abcQ"]:(<class 'KeyError'>, KeyError('abcQ',))
vim.options[""]:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
>>> Testing StringToChars using vim.options[%s]
vim.options[1]:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
vim.options[b"\0"]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
vim.options["\0"]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>> OptionsContains
>>> Testing StringToChars using %s in vim.options
1 in vim.options:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
b"\0" in vim.options:(<class 'TypeError'>, TypeError('expected bytes with no null',))
"\0" in vim.options:(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
> Dictionary
>> DictionaryConstructor
vim.Dictionary("abcI"):(<class 'ValueError'>, ValueError('expected sequence element of size 2, but got sequence of size 1',))
>> DictionarySetattr
del d.locked:(<class 'AttributeError'>, AttributeError('cannot delete vim.Dictionary attributes',))
d.locked = FailingTrue():(<class 'NotImplementedError'>, NotImplementedError('bool',))
vim.vvars.locked = False:(<class 'TypeError'>, TypeError('cannot modify fixed dictionary',))
d.scope = True:(<class 'AttributeError'>, AttributeError('cannot set attribute scope',))
d.xxx = True:(<class 'AttributeError'>, AttributeError('cannot set attribute xxx',))
>> _DictionaryItem
d.get("a", 2, 3):(<class 'TypeError'>, TypeError('function takes at most 2 arguments (3 given)',))
>>> Testing StringToChars using d.get(%s)
d.get(1):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.get(b"\0"):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.get("\0"):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
d.pop("a"):(<class 'KeyError'>, KeyError('a',))
dl.pop("a"):(<class 'vim.error'>, error('dictionary is locked',))
>> DictionaryContains
"" in d:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
0 in d:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
>> DictionaryIterNext
for i in ned: ned["a"] = 1:(<class 'RuntimeError'>, RuntimeError('hashtab changed during iteration',))
>> DictionaryAssItem
dl["b"] = 1:(<class 'vim.error'>, error('dictionary is locked',))
>>> Testing StringToChars using d[%s] = 1
d[1] = 1:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d[b"\0"] = 1:(<class 'TypeError'>, TypeError('expected bytes with no null',))
d["\0"] = 1:(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d["a"] = {%s : 1}
d["a"] = {1 : 1}:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d["a"] = {b"\0" : 1}:(<class 'TypeError'>, TypeError('expected bytes with no null',))
d["a"] = {"\0" : 1}:(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d["a"] = {"abcF" : {%s : 1}}
d["a"] = {"abcF" : {1 : 1}}:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d["a"] = {"abcF" : {b"\0" : 1}}:(<class 'TypeError'>, TypeError('expected bytes with no null',))
d["a"] = {"abcF" : {"\0" : 1}}:(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d["a"] = {"abcF" : Mapping({%s : 1})}
d["a"] = {"abcF" : Mapping({1 : 1})}:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d["a"] = {"abcF" : Mapping({b"\0" : 1})}:(<class 'TypeError'>, TypeError('expected bytes with no null',))
d["a"] = {"abcF" : Mapping({"\0" : 1})}:(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using d["a"] = {"abcF" : %s}
d["a"] = {"abcF" : FailingIter()}:(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
d["a"] = {"abcF" : FailingIterNext()}:(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using d["a"] = {"abcF" : %s}
d["a"] = {"abcF" : None}:(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
d["a"] = {"abcF" : {b"": 1}}:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d["a"] = {"abcF" : {"": 1}}:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d["a"] = {"abcF" : FailingMapping()}:(<class 'NotImplementedError'>, NotImplementedError('keys',))
d["a"] = {"abcF" : FailingMappingKey()}:(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
d["a"] = {"abcF" : FailingNumber()}:(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing StringToChars using d["a"] = Mapping({%s : 1})
d["a"] = Mapping({1 : 1}):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d["a"] = Mapping({b"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d["a"] = Mapping({"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d["a"] = Mapping({"abcG" : {%s : 1}})
d["a"] = Mapping({"abcG" : {1 : 1}}):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d["a"] = Mapping({"abcG" : {b"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d["a"] = Mapping({"abcG" : {"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d["a"] = Mapping({"abcG" : Mapping({%s : 1})})
d["a"] = Mapping({"abcG" : Mapping({1 : 1})}):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d["a"] = Mapping({"abcG" : Mapping({b"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d["a"] = Mapping({"abcG" : Mapping({"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using d["a"] = Mapping({"abcG" : %s})
d["a"] = Mapping({"abcG" : FailingIter()}):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
d["a"] = Mapping({"abcG" : FailingIterNext()}):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using d["a"] = Mapping({"abcG" : %s})
d["a"] = Mapping({"abcG" : None}):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
d["a"] = Mapping({"abcG" : {b"": 1}}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d["a"] = Mapping({"abcG" : {"": 1}}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d["a"] = Mapping({"abcG" : FailingMapping()}):(<class 'NotImplementedError'>, NotImplementedError('keys',))
d["a"] = Mapping({"abcG" : FailingMappingKey()}):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
d["a"] = Mapping({"abcG" : FailingNumber()}):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing *Iter* using d["a"] = %s
d["a"] = FailingIter():(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
d["a"] = FailingIterNext():(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using d["a"] = %s
d["a"] = None:(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
d["a"] = {b"": 1}:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d["a"] = {"": 1}:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d["a"] = FailingMapping():(<class 'NotImplementedError'>, NotImplementedError('keys',))
d["a"] = FailingMappingKey():(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
d["a"] = FailingNumber():(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>> DictionaryUpdate
>>> kwargs
>>> iter
d.update(FailingMapping()):(<class 'NotImplementedError'>, NotImplementedError('keys',))
d.update([FailingIterNext()]):(<class 'NotImplementedError'>, NotImplementedError('next',))
d.update([FailingIterNextN(1)]):(<class 'NotImplementedError'>, NotImplementedError('next N',))
>>> Testing *Iter* using d.update(%s)
d.update(FailingIter()):(<class 'NotImplementedError'>, NotImplementedError('iter',))
d.update(FailingIterNext()):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing StringToChars using d.update({%s : 1})
d.update({1 : 1}):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.update({b"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.update({"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d.update({"abcF" : {%s : 1}})
d.update({"abcF" : {1 : 1}}):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.update({"abcF" : {b"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.update({"abcF" : {"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d.update({"abcF" : Mapping({%s : 1})})
d.update({"abcF" : Mapping({1 : 1})}):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.update({"abcF" : Mapping({b"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.update({"abcF" : Mapping({"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using d.update({"abcF" : %s})
d.update({"abcF" : FailingIter()}):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
d.update({"abcF" : FailingIterNext()}):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using d.update({"abcF" : %s})
d.update({"abcF" : None}):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
d.update({"abcF" : {b"": 1}}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d.update({"abcF" : {"": 1}}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d.update({"abcF" : FailingMapping()}):(<class 'NotImplementedError'>, NotImplementedError('keys',))
d.update({"abcF" : FailingMappingKey()}):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
d.update({"abcF" : FailingNumber()}):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing StringToChars using d.update(Mapping({%s : 1}))
d.update(Mapping({1 : 1})):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.update(Mapping({b"\0" : 1})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.update(Mapping({"\0" : 1})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d.update(Mapping({"abcG" : {%s : 1}}))
d.update(Mapping({"abcG" : {1 : 1}})):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.update(Mapping({"abcG" : {b"\0" : 1}})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.update(Mapping({"abcG" : {"\0" : 1}})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d.update(Mapping({"abcG" : Mapping({%s : 1})}))
d.update(Mapping({"abcG" : Mapping({1 : 1})})):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.update(Mapping({"abcG" : Mapping({b"\0" : 1})})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.update(Mapping({"abcG" : Mapping({"\0" : 1})})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using d.update(Mapping({"abcG" : %s}))
d.update(Mapping({"abcG" : FailingIter()})):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
d.update(Mapping({"abcG" : FailingIterNext()})):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using d.update(Mapping({"abcG" : %s}))
d.update(Mapping({"abcG" : None})):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
d.update(Mapping({"abcG" : {b"": 1}})):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d.update(Mapping({"abcG" : {"": 1}})):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d.update(Mapping({"abcG" : FailingMapping()})):(<class 'NotImplementedError'>, NotImplementedError('keys',))
d.update(Mapping({"abcG" : FailingMappingKey()})):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
d.update(Mapping({"abcG" : FailingNumber()})):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing *Iter* using d.update(%s)
d.update(FailingIter()):(<class 'NotImplementedError'>, NotImplementedError('iter',))
d.update(FailingIterNext()):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using d.update(%s)
d.update(None):(<class 'TypeError'>, TypeError("'NoneType' object is not iterable",))
d.update({b"": 1}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d.update({"": 1}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d.update(FailingMapping()):(<class 'NotImplementedError'>, NotImplementedError('keys',))
d.update(FailingMappingKey()):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
d.update(FailingNumber()):(<class 'TypeError'>, TypeError("'FailingNumber' object is not iterable",))
<<< Finished
>>> Testing StringToChars using d.update(((%s, 0),))
d.update(((1, 0),)):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.update(((b"\0", 0),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.update((("\0", 0),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d.update((("a", {%s : 1}),))
d.update((("a", {1 : 1}),)):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.update((("a", {b"\0" : 1}),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.update((("a", {"\0" : 1}),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d.update((("a", {"abcF" : {%s : 1}}),))
d.update((("a", {"abcF" : {1 : 1}}),)):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.update((("a", {"abcF" : {b"\0" : 1}}),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.update((("a", {"abcF" : {"\0" : 1}}),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d.update((("a", {"abcF" : Mapping({%s : 1})}),))
d.update((("a", {"abcF" : Mapping({1 : 1})}),)):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.update((("a", {"abcF" : Mapping({b"\0" : 1})}),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.update((("a", {"abcF" : Mapping({"\0" : 1})}),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using d.update((("a", {"abcF" : %s}),))
d.update((("a", {"abcF" : FailingIter()}),)):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
d.update((("a", {"abcF" : FailingIterNext()}),)):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using d.update((("a", {"abcF" : %s}),))
d.update((("a", {"abcF" : None}),)):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
d.update((("a", {"abcF" : {b"": 1}}),)):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d.update((("a", {"abcF" : {"": 1}}),)):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d.update((("a", {"abcF" : FailingMapping()}),)):(<class 'NotImplementedError'>, NotImplementedError('keys',))
d.update((("a", {"abcF" : FailingMappingKey()}),)):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
d.update((("a", {"abcF" : FailingNumber()}),)):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing StringToChars using d.update((("a", Mapping({%s : 1})),))
d.update((("a", Mapping({1 : 1})),)):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.update((("a", Mapping({b"\0" : 1})),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.update((("a", Mapping({"\0" : 1})),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d.update((("a", Mapping({"abcG" : {%s : 1}})),))
d.update((("a", Mapping({"abcG" : {1 : 1}})),)):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.update((("a", Mapping({"abcG" : {b"\0" : 1}})),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.update((("a", Mapping({"abcG" : {"\0" : 1}})),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using d.update((("a", Mapping({"abcG" : Mapping({%s : 1})})),))
d.update((("a", Mapping({"abcG" : Mapping({1 : 1})})),)):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
d.update((("a", Mapping({"abcG" : Mapping({b"\0" : 1})})),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
d.update((("a", Mapping({"abcG" : Mapping({"\0" : 1})})),)):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using d.update((("a", Mapping({"abcG" : %s})),))
d.update((("a", Mapping({"abcG" : FailingIter()})),)):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
d.update((("a", Mapping({"abcG" : FailingIterNext()})),)):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using d.update((("a", Mapping({"abcG" : %s})),))
d.update((("a", Mapping({"abcG" : None})),)):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
d.update((("a", Mapping({"abcG" : {b"": 1}})),)):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d.update((("a", Mapping({"abcG" : {"": 1}})),)):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d.update((("a", Mapping({"abcG" : FailingMapping()})),)):(<class 'NotImplementedError'>, NotImplementedError('keys',))
d.update((("a", Mapping({"abcG" : FailingMappingKey()})),)):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
d.update((("a", Mapping({"abcG" : FailingNumber()})),)):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing *Iter* using d.update((("a", %s),))
d.update((("a", FailingIter()),)):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
d.update((("a", FailingIterNext()),)):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using d.update((("a", %s),))
d.update((("a", None),)):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
d.update((("a", {b"": 1}),)):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d.update((("a", {"": 1}),)):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
d.update((("a", FailingMapping()),)):(<class 'NotImplementedError'>, NotImplementedError('keys',))
d.update((("a", FailingMappingKey()),)):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
d.update((("a", FailingNumber()),)):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>> DictionaryPopItem
d.popitem(1, 2):(<class 'TypeError'>, TypeError('popitem() takes no arguments (2 given)',))
>> DictionaryHasKey
d.has_key():(<class 'TypeError'>, TypeError('has_key() takes exactly one argument (0 given)',))
> List
>> ListConstructor
vim.List(1, 2):(<class 'TypeError'>, TypeError('function takes at most 1 argument (2 given)',))
vim.List(a=1):(<class 'TypeError'>, TypeError('list constructor does not accept keyword arguments',))
>>> Testing *Iter* using vim.List(%s)
vim.List(FailingIter()):(<class 'NotImplementedError'>, NotImplementedError('iter',))
vim.List(FailingIterNext()):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing StringToChars using vim.List([{%s : 1}])
vim.List([{1 : 1}]):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
vim.List([{b"\0" : 1}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
vim.List([{"\0" : 1}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using vim.List([{"abcF" : {%s : 1}}])
vim.List([{"abcF" : {1 : 1}}]):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
vim.List([{"abcF" : {b"\0" : 1}}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
vim.List([{"abcF" : {"\0" : 1}}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using vim.List([{"abcF" : Mapping({%s : 1})}])
vim.List([{"abcF" : Mapping({1 : 1})}]):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
vim.List([{"abcF" : Mapping({b"\0" : 1})}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
vim.List([{"abcF" : Mapping({"\0" : 1})}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using vim.List([{"abcF" : %s}])
vim.List([{"abcF" : FailingIter()}]):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
vim.List([{"abcF" : FailingIterNext()}]):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using vim.List([{"abcF" : %s}])
vim.List([{"abcF" : None}]):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
vim.List([{"abcF" : {b"": 1}}]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
vim.List([{"abcF" : {"": 1}}]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
vim.List([{"abcF" : FailingMapping()}]):(<class 'NotImplementedError'>, NotImplementedError('keys',))
vim.List([{"abcF" : FailingMappingKey()}]):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
vim.List([{"abcF" : FailingNumber()}]):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing StringToChars using vim.List([Mapping({%s : 1})])
vim.List([Mapping({1 : 1})]):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
vim.List([Mapping({b"\0" : 1})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
vim.List([Mapping({"\0" : 1})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using vim.List([Mapping({"abcG" : {%s : 1}})])
vim.List([Mapping({"abcG" : {1 : 1}})]):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
vim.List([Mapping({"abcG" : {b"\0" : 1}})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
vim.List([Mapping({"abcG" : {"\0" : 1}})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using vim.List([Mapping({"abcG" : Mapping({%s : 1})})])
vim.List([Mapping({"abcG" : Mapping({1 : 1})})]):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
vim.List([Mapping({"abcG" : Mapping({b"\0" : 1})})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
vim.List([Mapping({"abcG" : Mapping({"\0" : 1})})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using vim.List([Mapping({"abcG" : %s})])
vim.List([Mapping({"abcG" : FailingIter()})]):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
vim.List([Mapping({"abcG" : FailingIterNext()})]):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using vim.List([Mapping({"abcG" : %s})])
vim.List([Mapping({"abcG" : None})]):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
vim.List([Mapping({"abcG" : {b"": 1}})]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
vim.List([Mapping({"abcG" : {"": 1}})]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
vim.List([Mapping({"abcG" : FailingMapping()})]):(<class 'NotImplementedError'>, NotImplementedError('keys',))
vim.List([Mapping({"abcG" : FailingMappingKey()})]):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
vim.List([Mapping({"abcG" : FailingNumber()})]):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing *Iter* using vim.List([%s])
vim.List([FailingIter()]):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
vim.List([FailingIterNext()]):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using vim.List([%s])
vim.List([None]):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
vim.List([{b"": 1}]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
vim.List([{"": 1}]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
vim.List([FailingMapping()]):(<class 'NotImplementedError'>, NotImplementedError('keys',))
vim.List([FailingMappingKey()]):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
vim.List([FailingNumber()]):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>> ListItem
l[1000]:(<class 'IndexError'>, IndexError('list index out of range',))
>> ListAssItem
ll[1] = 2:(<class 'vim.error'>, error('list is locked',))
l[1000] = 3:(<class 'IndexError'>, IndexError('list index out of range',))
>> ListAssSlice
ll[1:100] = "abcJ":(<class 'vim.error'>, error('list is locked',))
>>> Testing *Iter* using l[:] = %s
l[:] = FailingIter():(<class 'NotImplementedError'>, NotImplementedError('iter',))
l[:] = FailingIterNext():(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
nel[1:10:2]  = "abcK":(<class 'ValueError'>, ValueError('attempt to assign sequence of size greater then 2 to extended slice',))
(b'a', b'b', b'c', b'O')
nel[1:10:2]  = "a":(<class 'ValueError'>, ValueError('attempt to assign sequence of size 1 to extended slice of size 2',))
(b'a', b'b', b'c', b'O')
nel[1:1:-1]  = "a":(<class 'ValueError'>, ValueError('attempt to assign sequence of size greater then 0 to extended slice',))
(b'a', b'b', b'c', b'O')
nel[:] = FailingIterNextN(2):(<class 'NotImplementedError'>, NotImplementedError('next N',))
(b'a', b'b', b'c', b'O')
>>> Testing StringToChars using l[:] = [{%s : 1}]
l[:] = [{1 : 1}]:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
l[:] = [{b"\0" : 1}]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
l[:] = [{"\0" : 1}]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using l[:] = [{"abcF" : {%s : 1}}]
l[:] = [{"abcF" : {1 : 1}}]:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
l[:] = [{"abcF" : {b"\0" : 1}}]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
l[:] = [{"abcF" : {"\0" : 1}}]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using l[:] = [{"abcF" : Mapping({%s : 1})}]
l[:] = [{"abcF" : Mapping({1 : 1})}]:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
l[:] = [{"abcF" : Mapping({b"\0" : 1})}]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
l[:] = [{"abcF" : Mapping({"\0" : 1})}]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using l[:] = [{"abcF" : %s}]
l[:] = [{"abcF" : FailingIter()}]:(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
l[:] = [{"abcF" : FailingIterNext()}]:(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using l[:] = [{"abcF" : %s}]
l[:] = [{"abcF" : None}]:(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
l[:] = [{"abcF" : {b"": 1}}]:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
l[:] = [{"abcF" : {"": 1}}]:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
l[:] = [{"abcF" : FailingMapping()}]:(<class 'NotImplementedError'>, NotImplementedError('keys',))
l[:] = [{"abcF" : FailingMappingKey()}]:(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
l[:] = [{"abcF" : FailingNumber()}]:(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing StringToChars using l[:] = [Mapping({%s : 1})]
l[:] = [Mapping({1 : 1})]:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
l[:] = [Mapping({b"\0" : 1})]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
l[:] = [Mapping({"\0" : 1})]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using l[:] = [Mapping({"abcG" : {%s : 1}})]
l[:] = [Mapping({"abcG" : {1 : 1}})]:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
l[:] = [Mapping({"abcG" : {b"\0" : 1}})]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
l[:] = [Mapping({"abcG" : {"\0" : 1}})]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using l[:] = [Mapping({"abcG" : Mapping({%s : 1})})]
l[:] = [Mapping({"abcG" : Mapping({1 : 1})})]:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
l[:] = [Mapping({"abcG" : Mapping({b"\0" : 1})})]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
l[:] = [Mapping({"abcG" : Mapping({"\0" : 1})})]:(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using l[:] = [Mapping({"abcG" : %s})]
l[:] = [Mapping({"abcG" : FailingIter()})]:(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
l[:] = [Mapping({"abcG" : FailingIterNext()})]:(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using l[:] = [Mapping({"abcG" : %s})]
l[:] = [Mapping({"abcG" : None})]:(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
l[:] = [Mapping({"abcG" : {b"": 1}})]:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
l[:] = [Mapping({"abcG" : {"": 1}})]:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
l[:] = [Mapping({"abcG" : FailingMapping()})]:(<class 'NotImplementedError'>, NotImplementedError('keys',))
l[:] = [Mapping({"abcG" : FailingMappingKey()})]:(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
l[:] = [Mapping({"abcG" : FailingNumber()})]:(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing *Iter* using l[:] = [%s]
l[:] = [FailingIter()]:(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
l[:] = [FailingIterNext()]:(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using l[:] = [%s]
l[:] = [None]:(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
l[:] = [{b"": 1}]:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
l[:] = [{"": 1}]:(<class 'ValueError'>, ValueError('empty keys are not allowed',))
l[:] = [FailingMapping()]:(<class 'NotImplementedError'>, NotImplementedError('keys',))
l[:] = [FailingMappingKey()]:(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
l[:] = [FailingNumber()]:(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>> ListConcatInPlace
>>> Testing *Iter* using l.extend(%s)
l.extend(FailingIter()):(<class 'NotImplementedError'>, NotImplementedError('iter',))
l.extend(FailingIterNext()):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing StringToChars using l.extend([{%s : 1}])
l.extend([{1 : 1}]):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
l.extend([{b"\0" : 1}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
l.extend([{"\0" : 1}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using l.extend([{"abcF" : {%s : 1}}])
l.extend([{"abcF" : {1 : 1}}]):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
l.extend([{"abcF" : {b"\0" : 1}}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
l.extend([{"abcF" : {"\0" : 1}}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using l.extend([{"abcF" : Mapping({%s : 1})}])
l.extend([{"abcF" : Mapping({1 : 1})}]):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
l.extend([{"abcF" : Mapping({b"\0" : 1})}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
l.extend([{"abcF" : Mapping({"\0" : 1})}]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using l.extend([{"abcF" : %s}])
l.extend([{"abcF" : FailingIter()}]):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
l.extend([{"abcF" : FailingIterNext()}]):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using l.extend([{"abcF" : %s}])
l.extend([{"abcF" : None}]):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
l.extend([{"abcF" : {b"": 1}}]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
l.extend([{"abcF" : {"": 1}}]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
l.extend([{"abcF" : FailingMapping()}]):(<class 'NotImplementedError'>, NotImplementedError('keys',))
l.extend([{"abcF" : FailingMappingKey()}]):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
l.extend([{"abcF" : FailingNumber()}]):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing StringToChars using l.extend([Mapping({%s : 1})])
l.extend([Mapping({1 : 1})]):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
l.extend([Mapping({b"\0" : 1})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
l.extend([Mapping({"\0" : 1})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using l.extend([Mapping({"abcG" : {%s : 1}})])
l.extend([Mapping({"abcG" : {1 : 1}})]):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
l.extend([Mapping({"abcG" : {b"\0" : 1}})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
l.extend([Mapping({"abcG" : {"\0" : 1}})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using l.extend([Mapping({"abcG" : Mapping({%s : 1})})])
l.extend([Mapping({"abcG" : Mapping({1 : 1})})]):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
l.extend([Mapping({"abcG" : Mapping({b"\0" : 1})})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
l.extend([Mapping({"abcG" : Mapping({"\0" : 1})})]):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using l.extend([Mapping({"abcG" : %s})])
l.extend([Mapping({"abcG" : FailingIter()})]):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
l.extend([Mapping({"abcG" : FailingIterNext()})]):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using l.extend([Mapping({"abcG" : %s})])
l.extend([Mapping({"abcG" : None})]):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
l.extend([Mapping({"abcG" : {b"": 1}})]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
l.extend([Mapping({"abcG" : {"": 1}})]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
l.extend([Mapping({"abcG" : FailingMapping()})]):(<class 'NotImplementedError'>, NotImplementedError('keys',))
l.extend([Mapping({"abcG" : FailingMappingKey()})]):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
l.extend([Mapping({"abcG" : FailingNumber()})]):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing *Iter* using l.extend([%s])
l.extend([FailingIter()]):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
l.extend([FailingIterNext()]):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using l.extend([%s])
l.extend([None]):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
l.extend([{b"": 1}]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
l.extend([{"": 1}]):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
l.extend([FailingMapping()]):(<class 'NotImplementedError'>, NotImplementedError('keys',))
l.extend([FailingMappingKey()]):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
l.extend([FailingNumber()]):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>> ListSetattr
del l.locked:(<class 'AttributeError'>, AttributeError('cannot delete vim.List attributes',))
l.locked = FailingTrue():(<class 'NotImplementedError'>, NotImplementedError('bool',))
l.xxx = True:(<class 'AttributeError'>, AttributeError('cannot set attribute xxx',))
> Function
>> FunctionConstructor
vim.Function("123"):(<class 'ValueError'>, ValueError('unnamed function 123 does not exist',))
vim.Function("xxx_non_existent_function_xxx"):(<class 'ValueError'>, ValueError('function xxx_non_existent_function_xxx does not exist',))
vim.Function("xxx#non#existent#function#xxx"):NOT FAILED
>> FunctionCall
>>> Testing StringToChars using f({%s : 1})
f({1 : 1}):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
f({b"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
f({"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using f({"abcF" : {%s : 1}})
f({"abcF" : {1 : 1}}):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
f({"abcF" : {b"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
f({"abcF" : {"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using f({"abcF" : Mapping({%s : 1})})
f({"abcF" : Mapping({1 : 1})}):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
f({"abcF" : Mapping({b"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
f({"abcF" : Mapping({"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using f({"abcF" : %s})
f({"abcF" : FailingIter()}):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
f({"abcF" : FailingIterNext()}):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using f({"abcF" : %s})
f({"abcF" : None}):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
f({"abcF" : {b"": 1}}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
f({"abcF" : {"": 1}}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
f({"abcF" : FailingMapping()}):(<class 'NotImplementedError'>, NotImplementedError('keys',))
f({"abcF" : FailingMappingKey()}):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
f({"abcF" : FailingNumber()}):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing StringToChars using f(Mapping({%s : 1}))
f(Mapping({1 : 1})):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
f(Mapping({b"\0" : 1})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
f(Mapping({"\0" : 1})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using f(Mapping({"abcG" : {%s : 1}}))
f(Mapping({"abcG" : {1 : 1}})):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
f(Mapping({"abcG" : {b"\0" : 1}})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
f(Mapping({"abcG" : {"\0" : 1}})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using f(Mapping({"abcG" : Mapping({%s : 1})}))
f(Mapping({"abcG" : Mapping({1 : 1})})):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
f(Mapping({"abcG" : Mapping({b"\0" : 1})})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
f(Mapping({"abcG" : Mapping({"\0" : 1})})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using f(Mapping({"abcG" : %s}))
f(Mapping({"abcG" : FailingIter()})):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
f(Mapping({"abcG" : FailingIterNext()})):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using f(Mapping({"abcG" : %s}))
f(Mapping({"abcG" : None})):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
f(Mapping({"abcG" : {b"": 1}})):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
f(Mapping({"abcG" : {"": 1}})):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
f(Mapping({"abcG" : FailingMapping()})):(<class 'NotImplementedError'>, NotImplementedError('keys',))
f(Mapping({"abcG" : FailingMappingKey()})):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
f(Mapping({"abcG" : FailingNumber()})):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing *Iter* using f(%s)
f(FailingIter()):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
f(FailingIterNext()):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using f(%s)
f(None):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
f({b"": 1}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
f({"": 1}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
f(FailingMapping()):(<class 'NotImplementedError'>, NotImplementedError('keys',))
f(FailingMappingKey()):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
f(FailingNumber()):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing StringToChars using fd(self={%s : 1})
fd(self={1 : 1}):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
fd(self={b"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
fd(self={"\0" : 1}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using fd(self={"abcF" : {%s : 1}})
fd(self={"abcF" : {1 : 1}}):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
fd(self={"abcF" : {b"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
fd(self={"abcF" : {"\0" : 1}}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using fd(self={"abcF" : Mapping({%s : 1})})
fd(self={"abcF" : Mapping({1 : 1})}):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
fd(self={"abcF" : Mapping({b"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
fd(self={"abcF" : Mapping({"\0" : 1})}):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using fd(self={"abcF" : %s})
fd(self={"abcF" : FailingIter()}):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
fd(self={"abcF" : FailingIterNext()}):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using fd(self={"abcF" : %s})
fd(self={"abcF" : None}):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
fd(self={"abcF" : {b"": 1}}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
fd(self={"abcF" : {"": 1}}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
fd(self={"abcF" : FailingMapping()}):(<class 'NotImplementedError'>, NotImplementedError('keys',))
fd(self={"abcF" : FailingMappingKey()}):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
fd(self={"abcF" : FailingNumber()}):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing StringToChars using fd(self=Mapping({%s : 1}))
fd(self=Mapping({1 : 1})):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
fd(self=Mapping({b"\0" : 1})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
fd(self=Mapping({"\0" : 1})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using fd(self=Mapping({"abcG" : {%s : 1}}))
fd(self=Mapping({"abcG" : {1 : 1}})):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
fd(self=Mapping({"abcG" : {b"\0" : 1}})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
fd(self=Mapping({"abcG" : {"\0" : 1}})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing StringToChars using fd(self=Mapping({"abcG" : Mapping({%s : 1})}))
fd(self=Mapping({"abcG" : Mapping({1 : 1})})):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
fd(self=Mapping({"abcG" : Mapping({b"\0" : 1})})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
fd(self=Mapping({"abcG" : Mapping({"\0" : 1})})):(<class 'TypeError'>, TypeError('expected bytes with no null',))
<<< Finished
>>> Testing *Iter* using fd(self=Mapping({"abcG" : %s}))
fd(self=Mapping({"abcG" : FailingIter()})):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim structure',))
fd(self=Mapping({"abcG" : FailingIterNext()})):(<class 'NotImplementedError'>, NotImplementedError('next',))
<<< Finished
>>> Testing ConvertFromPyObject using fd(self=Mapping({"abcG" : %s}))
fd(self=Mapping({"abcG" : None})):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim structure',))
fd(self=Mapping({"abcG" : {b"": 1}})):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
fd(self=Mapping({"abcG" : {"": 1}})):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
fd(self=Mapping({"abcG" : FailingMapping()})):(<class 'NotImplementedError'>, NotImplementedError('keys',))
fd(self=Mapping({"abcG" : FailingMappingKey()})):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
fd(self=Mapping({"abcG" : FailingNumber()})):(<class 'NotImplementedError'>, NotImplementedError('int',))
<<< Finished
>>> Testing *Iter* using fd(self=%s)
fd(self=FailingIter()):(<class 'TypeError'>, TypeError('unable to convert FailingIter to vim dictionary',))
fd(self=FailingIterNext()):(<class 'TypeError'>, TypeError('unable to convert FailingIterNext to vim dictionary',))
<<< Finished
>>> Testing ConvertFromPyObject using fd(self=%s)
fd(self=None):(<class 'TypeError'>, TypeError('unable to convert NoneType to vim dictionary',))
fd(self={b"": 1}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
fd(self={"": 1}):(<class 'ValueError'>, ValueError('empty keys are not allowed',))
fd(self=FailingMapping()):(<class 'NotImplementedError'>, NotImplementedError('keys',))
fd(self=FailingMappingKey()):(<class 'NotImplementedError'>, NotImplementedError('getitem:mappingkey',))
fd(self=FailingNumber()):(<class 'TypeError'>, TypeError('unable to convert FailingNumber to vim dictionary',))
<<< Finished
>>> Testing ConvertFromPyMapping using fd(self=%s)
fd(self=[]):(<class 'AttributeError'>, AttributeError('keys',))
<<< Finished
> TabPage
>> TabPageAttr
vim.current.tabpage.xxx:(<class 'AttributeError'>, AttributeError("'vim.tabpage' object has no attribute 'xxx'",))
> TabList
>> TabListItem
vim.tabpages[1000]:(<class 'IndexError'>, IndexError('no such tab page',))
> Window
>> WindowAttr
vim.current.window.xxx:(<class 'AttributeError'>, AttributeError("'vim.window' object has no attribute 'xxx'",))
>> WindowSetattr
vim.current.window.buffer = 0:(<class 'TypeError'>, TypeError('readonly attribute: buffer',))
vim.current.window.cursor = (100000000, 100000000):(<class 'vim.error'>, error('cursor position outside buffer',))
vim.current.window.cursor = True:(<class 'TypeError'>, TypeError('argument must be 2-item sequence, not bool',))
>>> Testing NumberToLong using vim.current.window.height = %s
vim.current.window.height = []:(<class 'TypeError'>, TypeError('expected int() or something supporting coercing to int(), but got list',))
vim.current.window.height = None:(<class 'TypeError'>, TypeError('expected int() or something supporting coercing to int(), but got NoneType',))
vim.current.window.height = -1:(<class 'ValueError'>, ValueError('number must be greater or equal to zero',))
<<< Finished
>>> Testing NumberToLong using vim.current.window.width = %s
vim.current.window.width = []:(<class 'TypeError'>, TypeError('expected int() or something supporting coercing to int(), but got list',))
vim.current.window.width = None:(<class 'TypeError'>, TypeError('expected int() or something supporting coercing to int(), but got NoneType',))
vim.current.window.width = -1:(<class 'ValueError'>, ValueError('number must be greater or equal to zero',))
<<< Finished
vim.current.window.xxxxxx = True:(<class 'AttributeError'>, AttributeError('xxxxxx',))
> WinList
>> WinListItem
vim.windows[1000]:(<class 'IndexError'>, IndexError('no such window',))
> Buffer
>> StringToLine (indirect)
vim.current.buffer[0] = "\na":(<class 'vim.error'>, error('string cannot contain newlines',))
vim.current.buffer[0] = b"\na":(<class 'vim.error'>, error('string cannot contain newlines',))
>> SetBufferLine (indirect)
vim.current.buffer[0] = True:(<class 'TypeError'>, TypeError('bad argument type for built-in operation',))
>> SetBufferLineList (indirect)
vim.current.buffer[:] = True:(<class 'TypeError'>, TypeError('bad argument type for built-in operation',))
vim.current.buffer[:] = ["\na", "bc"]:(<class 'vim.error'>, error('string cannot contain newlines',))
>> InsertBufferLines (indirect)
vim.current.buffer.append(None):(<class 'TypeError'>, TypeError('bad argument type for built-in operation',))
vim.current.buffer.append(["\na", "bc"]):(<class 'vim.error'>, error('string cannot contain newlines',))
vim.current.buffer.append("\nbc"):(<class 'vim.error'>, error('string cannot contain newlines',))
>> RBItem
vim.current.buffer[100000000]:(<class 'IndexError'>, IndexError('line number out of range',))
>> RBAsItem
vim.current.buffer[100000000] = "":(<class 'IndexError'>, IndexError('line number out of range',))
>> BufferAttr
vim.current.buffer.xxx:(<class 'AttributeError'>, AttributeError("'vim.buffer' object has no attribute 'xxx'",))
>> BufferSetattr
vim.current.buffer.name = True:(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got bool',))
vim.current.buffer.xxx = True:(<class 'AttributeError'>, AttributeError('xxx',))
>> BufferMark
vim.current.buffer.mark(0):(<class 'TypeError'>, TypeError('expected bytes() or str() instance, but got int',))
vim.current.buffer.mark("abcM"):(<class 'ValueError'>, ValueError('mark name must be a single character',))
vim.current.buffer.mark("!"):(<class 'vim.error'>, error('invalid mark name',))
>> BufferRange
vim.current.buffer.range(1, 2, 3):(<class 'TypeError'>, TypeError('function takes exactly 2 arguments (3 given)',))
> BufMap
>> BufMapItem
vim.buffers[100000000]:(<class 'KeyError'>, KeyError(100000000,))
>>> Testing NumberToLong using vim.buffers[%s]
vim.buffers[[]]:(<class 'TypeError'>, TypeError('expected int() or something supporting coercing to int(), but got list',))
vim.buffers[None]:(<class 'TypeError'>, TypeError('expected int() or something supporting coercing to int(), but got NoneType',))
vim.buffers[-1]:(<class 'ValueError'>, ValueError('number must be greater then zero',))
vim.buffers[0]:(<class 'ValueError'>, ValueError('number must be greater then zero',))
<<< Finished
> Current
>> CurrentGetattr
vim.current.xxx:(<class 'AttributeError'>, AttributeError("'vim.currentdata' object has no attribute 'xxx'",))
>> CurrentSetattr
vim.current.line = True:(<class 'TypeError'>, TypeError('bad argument type for built-in operation',))
vim.current.buffer = True:(<class 'TypeError'>, TypeError('expected vim.Buffer object, but got bool',))
vim.current.window = True:(<class 'TypeError'>, TypeError('expected vim.Window object, but got bool',))
vim.current.tabpage = True:(<class 'TypeError'>, TypeError('expected vim.TabPage object, but got bool',))
vim.current.xxx = True:(<class 'AttributeError'>, AttributeError('xxx',))
['.']
'.'
3,xx
before
after
pythonx/topmodule/__init__.py
pythonx/topmodule/submodule/__init__.py
pythonx/topmodule/submodule/subsubmodule/subsubsubmodule.py
vim.command("throw 'abcN'"):(<class 'vim.error'>, error('abcN',))
Exe("throw 'def'"):(<class 'vim.error'>, error('def',))
vim.eval("Exe('throw ''ghi''')"):(<class 'vim.error'>, error('ghi',))
vim.eval("Exe('echoerr ''jkl''')"):(<class 'vim.error'>, error('Vim(echoerr):jkl',))
vim.eval("Exe('xxx_non_existent_command_xxx')"):(<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
vim.eval("xxx_unknown_function_xxx()"):(<class 'vim.error'>, error('Vim:E117: Unknown function: xxx_unknown_function_xxx',))
vim.bindeval("Exe('xxx_non_existent_command_xxx')"):(<class 'vim.error'>, error('Vim:E492: Not an editor command: xxx_non_existent_command_xxx',))
Caught KeyboardInterrupt
Running :put
No exception

