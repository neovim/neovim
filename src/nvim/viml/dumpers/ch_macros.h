#ifndef NVIM_VIML_DUMPERS_CH_MACROS_H
#define NVIM_VIML_DUMPERS_CH_MACROS_H
#undef NVIM_VIML_DUMPERS_CH_MACROS_H
// ^ Guard is never used. Makes linter happy.

#include <stddef.h>
#include "nvim/vim.h"
#include "nvim/viml/dumpers/dumpers.h"

/// @def CH_MACROS_DEFINE_LENGTH
/// @brief If set, `s*_len` functions will be defined
///
/// Defined functions will have signature `size_t f(CH_MACROS_OPTIONS_TYPE o,
/// ...)`. They are supposed to return a value that is greater then or equal to
/// the amount of bytes resulting string will occupy.

/// @def CH_MACROS_DEFINE_FWRITE
/// @brief If set, `*` functions will be defined
///
/// Defined functions will have signature `int f(CH_MACROS_OPTIONS_TYPE o, ...,
/// Writer write, void *cookie)`. They are supposed to write resulting string
/// using given `write` function.
///
/// @note If neither #CH_MACROS_DEFINE_LENGTH and #CH_MACROS_DEFINE_FWRITE
///       macros are defined then functions with `void f(CH_MACROS_OPTIONS_TYPE
///       o, ..., char **pp_)` signature are defined. They are supposed to write
///       resulting string to `**pp_` and advance `*pp_` to the end of written
///       string. They are not supposed to output trailing NUL though.

/// @def CH_MACROS_INDENT_STR
/// @brief NUL-terminated indentation string

/// @def CH_MACROS_OPTIONS_TYPE
/// @brief Type of the first function argument
///
/// Is used in #FDEC macros.

/// @def FNAME
/// @brief Expand into proper function name
///
/// Expands to
///
/// - `s{f}` if neither of #CH_MACROS_DEFINE_LENGTH and #CH_MACROS_DEFINE_FWRITE
///   macros are defined,
/// - to `s{f}_len` if #CH_MACROS_DEFINE_LENGTH macros is defined and
/// - to `{f}` if #CH_MACROS_DEFINE_FWRITE macros is defined.

/// @def F
/// @brief Call given function with proper name and some predefined arguments
///
/// @param  f    Called function.
/// @param  ...  Function arguments that are not predefined.
///
/// @note Function return value is handled by macros itself. You should not
///       expect macros to return anything.

/// @def F_PTR
/// @brief Call given pointer to the function with some predefined arguments
///
/// @param  f    Called function pointer.
/// @param  ...  Function arguments that are not predefined.
///
/// @note Function return value is handled by macros itself. You should not
///       expect macros to return anything.

/// @def F_NOOPT
/// @brief Like #F, but without predefined option argument

/// @def F_PTR_NOOPT
/// @brief Like #F_PTR, but without predefined option argument

/// @def F_ESCAPED
/// @brief Like #F(f, ...), but also escapes characters listed in e with '\\'
///
/// @param  e    Escaped characters. This parameter is used only once.

/// @def FDEC
/// @brief Generate function declaration
///
/// @param  f    Function name. Passed to #FNAME(f) to construct actual function
///              name.

/// @def FDEC_TYPEDEF
/// @brief Like #FDEC, but generates pointer declaration for typedef
///
/// As it generates type name then `s` prefix is replaced with `Str` suffix,
/// `_len` suffix is replaced with `Len` prefix.
///
/// See also #FTYPE and #FDEC_TYPEDEF_ALL.

/// @def FDEC_TYPEDEF_ALL
/// @brief Generated three typedefs with names like described in #FDEC_TYPEDEF

/// @def FTYPE
/// @brief Add appropriate suffixes for type name generated by #FDEC_TYPEDEF
///
/// @return Appropriate type name.

/// @def FUNCTION_START
/// @brief Macros that should start each function defined with #FDEC

/// @def EARLY_RETURN
/// @brief Macros that should be used to return when function does nothing
///
/// @warning Do not use this macros to return when function has written
///          something. It should be used only when function has nothing to do
///          and thus may early return.

/// @def FUNCTION_END
/// @brief Macros that should end each function defined with #FDEC
///
/// May be used to return from the function when it did something.

/// @def WC
/// @brief Write given character

/// @def WS
/// @brief Write given static string
///
/// May be used with any string for which `sizeof(s) - 1` returns its length.
///
/// @param  s  String which will be written. @warning {May be substituted more
///            then once.}

/// @def W
/// @brief Write given NUL-terminated string

/// @def W_LEN
/// @brief Write string with given length
///
/// @param  s       String which will be written.
/// @param  length  Length of this string.

/// @def W_ESCAPED
/// @brief Write string, escaping certain characters with backslash
///
/// @param  s         String which will be written.
/// @param  escchars  Characters that should be escaped.

/// @def W_NL
/// @brief Write new line.
///
/// Is used for writing newline defined in StyleOptions. Unlike most other
/// definitions this was created for technical reasons: some newlines may be
/// part of some commands.

/// @def FILL
/// @brief Write some character multiple times
///
/// @param  c       Character that will be written.
/// @param  length  Number of times it should be written.

/// @def WINDENT
/// @brief Write indentation
///
/// @param  length  Indentation level.

/// @def SPACES
/// @brief Write given amount of spaces

/// @def CALL_LEN
/// @brief Call `s*_len` variant of function
///
/// @return Length returned by given function.

/// @def W_END
/// @brief Write string specified by (start, end) pair
///
/// @param  s  Pointer to the start of the written string.
/// @param  e  Pointer to the last character of the written string.

/// @def W_EXPR_POS
/// @brief Write ExpressionNode, propagate FAIL
///
/// @param  s     Pointer to the start of the string.
/// @param  node  Expression node which is being dumped.
///
/// Data written is string between node->start and node->end, inclusive.

#if defined(CH_MACROS_DEFINE_LENGTH) && defined(CH_MACROS_DEFINE_FWRITE)
# error Trying to use both CH_MACROS_DEFINE_LENGTH and CH_MACROS_DEFINE_FWRITE.
#endif

#ifdef FNAME
# undef FNAME
#endif
#ifdef _FARGS
# undef _FARGS
#endif
#ifdef FTYPE
# undef FTYPE
#endif
#ifdef F
# undef F
#endif
#ifdef F_PTR_NOOPT
# undef F_PTR_NOOPT
#endif
#ifdef F_ESCAPED
# undef F_ESCAPED
#endif
#ifdef FDEC
# undef FDEC
#endif
#ifdef FDEC_TYPEDEF
# undef FDEC_TYPEDEF
#endif
#ifdef FUNCTION_START
# undef FUNCTION_START
#endif
#ifdef EARLY_RETURN
# undef EARLY_RETURN
#endif
#ifdef FUNCTION_END
# undef FUNCTION_END
#endif
#ifdef WC
# undef WC
#endif
#ifdef WS
# undef WS
#endif
#ifdef W
# undef W
#endif
#ifdef W_LEN
# undef W_LEN
#endif
#ifdef FILL
# undef FILL
#endif
#ifdef WINDENT
# undef WINDENT
#endif

#ifdef CH_MACROS_DEFINE_LENGTH
# define FNAME(f) s##f##_len
# define F_PTR_NOOPT(fp, ...) \
    len += (*(fp))(__VA_ARGS__)
# define F_ESCAPED(f, e, ...) \
    len += 2 * CALL_LEN(f, __VA_ARGS__)
# define _FARGS(...) CH_MACROS_OPTIONS_TYPE o, __VA_ARGS__
# define FDEC(f, ...) \
    size_t FNAME(f)(_FARGS(__VA_ARGS__))
# define FTYPE(t) t##StrLen
# define FDEC_TYPEDEF(t, ...) \
    size_t (*FTYPE(t))(_FARGS(__VA_ARGS__))  // NOLINT
# define FUNCTION_START \
    size_t len = 0
# define EARLY_RETURN \
    return len
# define FUNCTION_END \
    return len
# define WC(c) \
    len++
# define WS(s) \
    len += sizeof(s) - 1
# define W(s) \
    len += STRLEN(s);
# define W_LEN(s, length) \
    len += length;
# define FILL(c, length) \
    len += length
# define WINDENT(length) \
    len += (length) * STRLEN(CH_MACROS_INDENT_STR)
#else
# ifdef CH_MACROS_DEFINE_FWRITE
#  define _WRITE(s, length) \
    do { \
      if (write_string_len((const char *) s, length, write, cookie) == FAIL) { \
        return FAIL; \
      } \
    } while (0)
#  define FNAME(f) f
#  define F_PTR_NOOPT(fp, ...) \
    do { \
      if ((*(fp))(__VA_ARGS__, write, cookie) == FAIL) { \
        return FAIL; \
      } \
    } while (0)
#  define _FARGS(...) CH_MACROS_OPTIONS_TYPE o, __VA_ARGS__, Writer write, \
                      void *cookie
#  define FDEC(f, ...) \
     int FNAME(f)(_FARGS(__VA_ARGS__))
#  define FTYPE(t) t
#  define FDEC_TYPEDEF(t, ...) \
     int (*FTYPE(t))(_FARGS(__VA_ARGS__))  // NOLINT
#  define FUNCTION_START
#  define EARLY_RETURN \
    return OK
#  define FUNCTION_END \
    return OK
#  define WC(c) \
    do { \
      char s[] = { c }; \
      _WRITE(s, 1); \
    } while (0)
#  define WS(s) \
    _WRITE(s, sizeof(s) - 1)
#  define W(s) \
    _WRITE(s, STRLEN(s))
#  define W_LEN(s, length) \
    _WRITE(s, length)
#  define FILL(c, length) \
    do { \
      size_t i = length; \
      while (i--) { \
        WC(c); \
      } \
    } while (0)
#  define F_ESCAPED(f, e, ...) \
    do { \
      const EscapedCookie new_cookie = { \
        .echars = e, \
        .write = write, \
        .cookie = cookie \
      }; \
      { \
        Writer write = &write_escaped_string_len; \
        void *cookie = (void *) &new_cookie; \
        F(f, __VA_ARGS__); \
      } \
    } while (0)
# else
#  define FNAME(f) s##f
#  define F_PTR_NOOPT(fp, ...) \
    (*(fp))(__VA_ARGS__, &p_)
#  define _FARGS(...) CH_MACROS_OPTIONS_TYPE o, __VA_ARGS__, char **pp_
#  define FDEC(f, ...) \
    void FNAME(f)(_FARGS(__VA_ARGS__))
#  define FTYPE(t) t##Str
#  define FDEC_TYPEDEF(t, ...) \
    void (*FTYPE(t))(_FARGS(__VA_ARGS__))  // NOLINT
#  define FUNCTION_START \
    char *p_ = *pp_
#  define EARLY_RETURN \
    return
#  define FUNCTION_END \
    do { \
      *pp_ = p_; \
      return; \
    } while (0)
#  define WC(c) \
    *p_++ = c
#  define WS(s) \
    do { \
      memcpy(p_, (const char *) s, sizeof(s) - 1); \
      p_ += sizeof(s) - 1; \
    } while (0)
#  define W(s) \
    do { \
      size_t len = STRLEN(s); \
      if (len) { \
        memcpy(p_, s, len); \
        p_ += len; \
      } \
    } while (0)
#  define W_LEN(s, length) \
    do { \
      if (length) { \
        memcpy(p_, s, length); \
        p_ += length; \
      } \
    } while (0)
#  define FILL(c, length) \
    memset(p_, c, length); \
    p_ += length
#  define F_ESCAPED(f, e, ...) \
    do { \
      char *arg_start = p_; \
      const char *const echars = e; \
      F(f, __VA_ARGS__); \
      while (arg_start < p_) { \
        if (strchr(echars, *arg_start) != NULL) { \
          STRMOVE(arg_start + 1, arg_start); \
          *arg_start = '\\'; \
          arg_start += 2; \
          p_++; \
        } else { \
          arg_start++; \
        } \
      } \
    } while (0)
# endif
# define WINDENT(length) \
    do { \
      const size_t mlen = length; \
      for (size_t i = 0; i < mlen; i++) { \
        W(CH_MACROS_INDENT_STR); \
      } \
    } while (0)
#endif

#define F_PTR(fp, ...) \
    F_PTR_NOOPT(fp, o, __VA_ARGS__)
#define F_NOOPT(f, ...) \
    F_PTR_NOOPT(&(FNAME(f)), __VA_ARGS__)
#define F(f, ...) \
    F_NOOPT(f, o, __VA_ARGS__)
#define FDEC_TYPEDEF_ALL(t, ...) \
    typedef size_t (*t##StrLen)(CH_MACROS_OPTIONS_TYPE, __VA_ARGS__); \
    typedef void (*t##Str)(CH_MACROS_OPTIONS_TYPE, __VA_ARGS__, char **); \
    typedef int (*t)(CH_MACROS_OPTIONS_TYPE, __VA_ARGS__, Writer, void *)
#define W_END(s, e) \
    W_LEN(s, (size_t) (e - s) + 1)
#define W_EXPR_POS(s, node) \
    W_LEN(s + node->start, node->end - node->start + 1)
#define W_ESCAPED(s, escchars) \
    do { \
      const char *const escchars_ = escchars; \
      for (const char *s_ = s; *s_; s_++) { \
        if (strchr(escchars_, *s_) != NULL) { \
          WC('\\'); \
        } \
        WC(*s_); \
      } \
    } while (false)
#define SPACES(length) \
    do { \
      if (length) { \
        FILL(' ', length); \
      } \
    } while (0)
#define CALL_LEN(f, ...) s##f##_len(o, __VA_ARGS__)

#define _APPLY(a, b) a(b)

#define W_NL _APPLY(W_LEN, NEWLINE)

#define SPACES_BEFORE_SUBSCRIPT2(a1, a2) SPACES(o->a1.a2.before_subscript)
#define SPACES_BEFORE_TEXT2(a1, a2)      SPACES(o->a1.a2.before_text)
#define SPACES_BEFORE_ATTRIBUTE2(a1, a2) SPACES(o->a1.a2.before_attribute)
#define SPACES_BEFORE_END2(a1, a2)       SPACES(o->a1.a2.before_end)
#define SPACES_AFTER_START2(a1, a2)      SPACES(o->a1.a2.after_start)

#define SPACES_BEFORE_END3(a1, a2, a3)   SPACES(o->a1.a2.a3.before_end)
#define SPACES_BEFORE3(a1, a2, a3)       SPACES(o->a1.a2.a3.before)
#define SPACES_AFTER_START3(a1, a2, a3)  SPACES(o->a1.a2.a3.after_start)
#define SPACES_AFTER3(a1, a2, a3)        SPACES(o->a1.a2.a3.after)

#define SPACES_BEFORE4(a1, a2, a3, a4)   SPACES(o->a1.a2.a3.a4.before)
#define SPACES_AFTER4(a1, a2, a3, a4)    SPACES(o->a1.a2.a3.a4.after)

#define ADD_TRAILING_COMMA2(a1, a2)      o->a1.a2.trailing_comma
#define GLOB_AST                         o->command.glob.ast_glob
#define SET_SHOW_SHORT                   o->command.set.display_short

#define USE_S_AMPERSAND                  o->command.substitute.use_ampersand
#define USE_EXPLICIT_NARGS               o->command.command.explicit_nargs
#define USE_HISTCHAR                     o->command.history.use_character

#define DO_CMD_SEPARATOR                 o->command.do_cmd.cmd_separator
#define AU_CMD_SEPARATOR                 o->command.autocmd.cmd_separator
#define CMD_CMD_SEPARATOR                o->command.command.cmd_separator
#define G_CMD_SEPARATOR                  o->command.global.cmd_separator

#define NEWLINE                          o->newline.string, o->newline.len

#define IS_MAGIC                         o->magic
#endif  // NVIM_VIML_DUMPERS_CH_MACROS_H
