-- Island of misfit toys.
--- @diagnostic disable: deprecated

local t = require('test.testutil')
local n = require('test.functional.testnvim')()
local api, eq, fn = n.api, t.eq, n.fn
local pcall_err, command = t.pcall_err, n.command

describe('deprecated', function()
  before_each(n.clear)

  describe('nvim_notify', function()
    it('can notify a info message', function()
      n.api.nvim_notify('hello world', 2, {})
    end)

    it('can be overridden', function()
      n.command('lua vim.notify = function(...) return 42 end')
      t.eq(42, n.api.nvim_exec_lua("return vim.notify('Hello world')", {}))
      n.api.nvim_notify('hello world', 4, {})
    end)
  end)

  describe('nvim_*get_option functions', function()
    it('does not leak memory', function()
      -- String opts caused memory leaks in these functions in Github#32361
      n.exec_lua([[
        vim.api.nvim_get_option('rtp')
        vim.api.nvim_win_get_option(vim.api.nvim_get_current_win(), 'foldmethod')
        vim.api.nvim_buf_get_option(0, 'fileformat')
      ]])
    end)
  end)

  describe('nvim_buf_get_mark', function()
    it('works', function()
      api.nvim_buf_set_lines(0, -1, -1, true, { 'a', 'bit of', 'text' })
      api.nvim_win_set_cursor(0, { 3, 4 })
      command('mark v')
      eq({ 3, 0 }, api.nvim_buf_get_mark(0, 'v'))
    end)
  end)

  describe('nvim_buf_set_mark', function()
    it('works with buffer local marks', function()
      api.nvim_buf_set_lines(0, -1, -1, true, { 'a', 'bit of', 'text' })
      eq(true, api.nvim_buf_set_mark(0, 'z', 1, 1, {}))
      eq({ 1, 1 }, api.nvim_buf_get_mark(0, 'z'))
      eq({ 0, 1, 2, 0 }, fn.getpos("'z"))
    end)
    it('works with file/uppercase marks', function()
      api.nvim_buf_set_lines(0, -1, -1, true, { 'a', 'bit of', 'text' })
      eq(true, api.nvim_buf_set_mark(0, 'Z', 3, 2, {}))
      eq({ 3, 2 }, api.nvim_buf_get_mark(0, 'Z'))
      eq({ api.nvim_get_current_buf(), 3, 3, 0 }, fn.getpos("'Z"))
    end)
    it('fails when invalid marks names are used', function()
      eq(false, pcall(api.nvim_buf_set_mark, 0, '!', 1, 0, {}))
      eq(false, pcall(api.nvim_buf_set_mark, 0, 'fail', 1, 0, {}))
    end)
    it('fails when invalid buffer number is used', function()
      eq(false, pcall(api.nvim_buf_set_mark, 99, 'a', 1, 1, {}))
    end)
    it('auto-loads unloaded buffer', function()
      local new_bufnr = fn.bufnr('set_mark', true)
      eq(false, api.nvim_buf_is_loaded(new_bufnr))
      eq(true, api.nvim_buf_set_mark(new_bufnr, 'A', 0, 0, {}))
      eq(true, api.nvim_buf_is_loaded(new_bufnr))
      eq({ 0, 0 }, api.nvim_buf_get_mark(new_bufnr, 'A'))
    end)
  end)

  describe('nvim_buf_del_mark', function()
    it('works with buffer local marks', function()
      api.nvim_buf_set_lines(0, -1, -1, true, { 'a', 'bit of', 'text' })
      api.nvim_buf_set_mark(0, 'z', 3, 1, {})
      eq(true, api.nvim_buf_del_mark(0, 'z'))
      eq({ 0, 0 }, api.nvim_buf_get_mark(0, 'z'))
    end)
    it('works with file/uppercase marks', function()
      api.nvim_buf_set_lines(0, -1, -1, true, { 'a', 'bit of', 'text' })
      api.nvim_buf_set_mark(0, 'Z', 3, 3, {})
      eq(true, api.nvim_buf_del_mark(0, 'Z'))
      eq({ 0, 0 }, api.nvim_buf_get_mark(0, 'Z'))
    end)
    it('returns false in marks not set in this buffer', function()
      local abuf = api.nvim_create_buf(false, true)
      api.nvim_buf_set_lines(abuf, -1, -1, true, { 'a', 'bit of', 'text' })
      api.nvim_buf_set_mark(abuf, 'A', 2, 2, {})
      eq(false, api.nvim_buf_del_mark(0, 'A'))
      eq({ 2, 2 }, api.nvim_buf_get_mark(abuf, 'A'))
    end)
    it('returns false if mark was not deleted', function()
      api.nvim_buf_set_lines(0, -1, -1, true, { 'a', 'bit of', 'text' })
      api.nvim_buf_set_mark(0, 'z', 3, 1, {})
      eq(true, api.nvim_buf_del_mark(0, 'z'))
      eq(false, api.nvim_buf_del_mark(0, 'z')) -- Mark was already deleted
    end)
    it('fails when invalid marks names are used', function()
      eq(false, pcall(api.nvim_buf_del_mark, 0, '!'))
      eq(false, pcall(api.nvim_buf_del_mark, 0, 'fail'))
    end)
    it('fails when invalid buffer number is used', function()
      eq(false, pcall(api.nvim_buf_del_mark, 99, 'a'))
    end)
  end)

  describe('nvim_get_mark', function()
    it('works', function()
      local buf = api.nvim_create_buf(false, true)
      api.nvim_buf_set_lines(buf, -1, -1, true, { 'a', 'bit of', 'text' })
      api.nvim_buf_set_mark(buf, 'F', 2, 2, {})
      api.nvim_buf_set_name(buf, 'mybuf')
      local mark = api.nvim_get_mark('F', {})
      -- Compare the path tail only
      t.matches('mybuf$', mark[4])
      eq({ 2, 2, buf, mark[4] }, mark)
    end)
    it('validation', function()
      eq("Invalid mark name (must be file/uppercase): 'f'", pcall_err(api.nvim_get_mark, 'f', {}))
      eq("Invalid mark name (must be file/uppercase): '!'", pcall_err(api.nvim_get_mark, '!', {}))
      eq(
        "Invalid mark name (must be a single char): 'fail'",
        pcall_err(api.nvim_get_mark, 'fail', {})
      )
    end)
    it('returns the expected when mark is not set', function()
      eq(true, api.nvim_del_mark('A'))
      eq({ 0, 0, 0, '' }, api.nvim_get_mark('A', {}))
    end)
    it('works with deleted buffers', function()
      local fname = t.tmpname()
      t.write_file(fname, 'a\nbit of\text')
      command('edit ' .. fname)
      local buf = api.nvim_get_current_buf()

      api.nvim_buf_set_mark(buf, 'F', 2, 2, {})
      command('new') -- Create new buf to avoid :bd failing
      command('bd! ' .. buf)
      os.remove(fname)

      local mark = api.nvim_get_mark('F', {})
      -- To avoid comparing relative vs absolute path
      local mfname = mark[4]
      local tail_patt = [[[\/][^\/]*$]]
      -- tail of paths should be equals
      eq(fname:match(tail_patt), mfname:match(tail_patt))
      eq({ 2, 2, buf, mark[4] }, mark)
    end)
  end)

  describe('nvim_del_mark', function()
    it('works', function()
      local buf = api.nvim_create_buf(false, true)
      api.nvim_buf_set_lines(buf, -1, -1, true, { 'a', 'bit of', 'text' })
      eq(true, api.nvim_buf_set_mark(buf, 'F', 2, 2, {}))
      eq(true, api.nvim_del_mark('F'))
      eq({ 0, 0 }, api.nvim_buf_get_mark(buf, 'F'))
    end)
    it('validation', function()
      eq("Invalid mark name (must be file/uppercase): 'f'", pcall_err(api.nvim_del_mark, 'f'))
      eq("Invalid mark name (must be file/uppercase): '!'", pcall_err(api.nvim_del_mark, '!'))
      eq("Invalid mark name (must be a single char): 'fail'", pcall_err(api.nvim_del_mark, 'fail'))
    end)
  end)
end)
